# 单例模式

分类：

-   饿汉式：类初始化时创建单例，线程安全，适用于单例占内存小的场景，否则推荐使用懒汉式延迟加载
-   懒汉式：需要创建单例实例的时候再创建，需要考虑线程安全(性能不太好)
-   双重检验锁：效率高。假如两个线程A、B，A执行了if( instance == null )语句，它会认为单例对象没有创建，此时线程切到B也， 执行了同样的语句，B也认为单例对象没有创建，然后两个线程依次执行同步代码块，并分别创建了一个单例对象
-   静态内部类：可以同时保证延迟加载和线程安全
-   枚举：保证线程安全和防止反射调用构造器，提供了自动序列化机制，防止反序列化的时候创建新的对象

使用场景：

-   要求生成唯一序列号的环境
-   在整个项目中需要一个共享访问点或共享数据，例如一个 Web 页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的
-   创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源
-   需要定义大量的静态常量和静态方法(如工具类)的环境，可以采用单例模式(或者static)

~~~java
// 饿汉
public class Singleton {
  private static final Singleton singleton = new Singleton();
  //限制产生多个对象 
  private Singleton(){} 
  public static Singleton getSingleton(){
    return singleton;
  }
  //类中其他方法，尽量是static 
  public static void doSomething(){
  }
}

// 懒汉
public class Singleton {
  private static final Singleton singleton = null;
  private Singleton(){} 
  public static Singleton getSingleton(){
    if (singleton == null) {
      singleton == new Singleton();
    }
    return singleton;
  }
}
// 解决方法：getSingleton前面加上synchronized
// 双重检验锁
public class Singleton {
  private static volatile Singleton singleton = null;
  private Singleton(){} 
  public static Singleton getSingleton(){
    if (singleton == null) {
      synchronized (Singleton.class) {
        if (singleton == null) {
          singleton == new Singleton();
        }
      }
    }
    return singleton;
  }
}
// 静态内部类
public class Singleton {
  private static class SingletonHolder{
    public static Singleton instance = new Singleton();
  }
  private Singleton(){} 
  public static Singleton newInstance(){
    return SingletonHolder.instance;
  }
}
// 枚举
public enum Singleton{
  instance;
  public voud whateverMethod(){}
}
~~~

# 工厂模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例话延迟到其子类

Creator抽象工厂

使用场景：大量不同种类的产品需要创建，且有不同的接口。jdbc连接数据库，硬件访问，降低对象的产生和销毁

# 抽象工厂模式

创建多个工厂类，提高工厂的拓展性。工厂模式专注于创建单一产品，而抽象工厂模式专注于创建产品族

# 模版方法模式

定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

抽象模版中，基本方法由子类实现，模版方法(一般加上final)为框架，调用基本方法

# 建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式关注基本方法的调用顺序，工厂模式侧重于创建。

使用场景：

-   相同的方法，不同的执行顺序，产生不同的事件结果时，可以使用该模式
-   多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时， 可以使用该模式
-   产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，可以使用该模式

# 代理模式

为其他对象提供一种代理以控制对这个对象的访问

普通代理就是我们要知道代理的存在，然后才能访问； 在该模式下，调用者只知代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色想怎么修改就怎么修改，对高层次的模块没有任何的影响，只要你实现了接口所对应的方法，该模式非常适合对扩展性要求较高的场合

强制代理则是调用者直接调用真实角色，而不用关心代理是否存在，其代理的产生是由真实角色决定的

动态代理根据被代理的接口生成所有的方法，也就是说给定一个接口，动态代理会宣称“我已经实现该接口下的所有方法了”

动态代理的意图：横切面编程，在不改变我们已有代码结构的情况下增强或控制对象的行为。 首要条件：被代理的类必须要实现一个接口。

# 原型模式

将一个对象作为原型进行复制核心，它的核心是原型类Prototype，需要实现Cloneable接口，和重写object类中的clone方法

优点：

-   性能优良，原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象

-   逃避构造函数的约束，这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的

使用场景：

-   资源优化场景，类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等
-   性能和安全要求的场景，通过new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模 式
-   一个对象多个修改者的场景 ，一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用

浅拷贝：Object 类提供的方法 clone 只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝，其他的原始类型比如 int、long、char、string(当做是原始类型)等都会被拷贝。 

注意：使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变对象。 

深拷贝：对私有的类变量进行独立的拷贝 如：thing.arrayList =(ArrayList<String>)this.arrayList.clone()；

~~~java
public class PrototypeClass implements Clonable {
  @Override
  public PrototypeClass clone() {
    PrototypeClass prototypeClass = null;
    try {
      prototypeClass = (PrototypeClass)super.clone();
    } catch (CloneNotSupportedException e) {
      // 异常处理
    }
    return prototypeClass；
  }
}
~~~

# 中介者模式

用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散， 而且可以独立地改变它们之间的交互

同事角色的两种行为：自发行为和依赖方法(必须依赖中介者)

>   为什么同事类要使用构造函数注入中介者，而中介者使用 getter/setter 方式注入同事类呢

这是因为同事类必须有中介者，而中介者却可以只有部分同事类

使用场景：中介者模式适用于多个对象之间紧密耦合的情况，紧密耦合的标准是：在类图中出现了蛛网状结构，即每个类都与其他的类有直接的联系。

# 命令模式

将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能

接收者(工作)、命令角色(声明命令)、调用者角色(接收命令并执行命令)

# 责任链模式

使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链， 并沿着这条链传递该请求，直到有对象处理它为止

抽象的处理者实现三个职责： 

一是定义一个请求的处理方法 handleMessage，唯一对外开放的方法

二是定义一个链的编排方法 setNext，设置下一个处理者

三是定义了具体的请求者必须实现的两个方法：定义自己能够处理的级别getHandlerLevel 和具体的处理任务 echo

注意事项： 链中节点数量需要控制，避免出现超长链的情况，一般的做法是在 Handler 中设置 一个最大节点数量，在 setNext 方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免无意识地破坏系统性能

# 装饰模式

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。增强的是单个对象的能力(不是类)。例子：Buffered系列类中的BufferedReader 和 BufferedWriter

使用场景：

-   需要扩展一个类的功能，或给一个类增加附加功能
-   需要动态地给一个对象增加功能，这些功能可以再动态地撤销
-   需要一批的兄弟类进行改装或加装功能，当然是首选装饰模式

# 策略模式

定义一组算法，将每个算法都封装起来，并且使它们之间可以互换

使用场景：

-   多个类只有在算法或行上稍有不同的场景

-   算法需要自由切换的场景

-   需要屏蔽算法规则的场景

    注意事项：具体策略数量超过4个，则需要考虑使用混合模式

~~~java
// 策略枚举
public enum Caculator {
    ADD("+") {
        public int exec(int a, int b) {
            return a + b;
        }
    },
    SUB("-") {
        public int exec(int a, int b) {
            return a - b;
        }
    };
    String value = "";
    private Caculator(String value) {
        this.value = value;
    }
    private String getValue() {
        return value;
    }
    public abstract int exec(int a, int b);
}
~~~

受枚举类型的限制，每个枚举项都是 public、final、static 的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色

致命缺陷： 所有的策略都需要暴露出去，由客户端决定使用哪一个策略

# 适配器模式

将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作

对象适配器和类适配器的区别： 类适配器是类间继承，对象适配器是对象的合成关系，也可以说是类的关联关系， 这是两者的根本区别。(实际项目中对象适配器使用到的场景相对比较多)

# 迭代器模式

它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节

迭代器模式已经被淘汰，java 中已经把迭代器运用到各个聚集类(collection)中了，使用java 自带的迭代器就已经满足我们的需求了

# 组合模式

将对象组合成树形结构以表示“部分-整体”的层次结构，使得用 户对单个对象和组合对象的使用具有一致性

使用场景：

-   维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理

-   从一个整体中能够独立出部分模块或功能的场景

    注意： 只要是树形结构，就考虑使用组合模式

# 观察者模式

定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，所有依赖于它的对象都会得到通知并被自动更新

使用场景：

-   关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系
-   事件多级触发场景
-   跨系统的消息交换场景，如消息队列的处理机制

注意：

-   广播链的问题。在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次(传递两次)
-   异步处理问题。观察者比较多，而且处理时间比较长，采用异步处理来考虑线程安全和队列的问题。

# 门面模式

要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用

使用场景：

-   一个复杂的模块或子系统提供一个供外界访问的接口
-   子系统相对独立——外界对子系统的访问只要黑箱操作即可
-   预防低水平人员带来的风险扩散 

注意： 一个子系统可以有多个门面，门面不参与子系统内的业务逻辑

# 备忘录模式

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态

使用场景：

-   需要保存和恢复数据的相关状态场景
-   提供一个可回滚(rollback)的操作
-   需要监控的副本场景中
-   数据库连接的事务管理就是用的备忘录模式。

注意：备忘录的生命期，备忘录的性能。不要在频繁建立备份的场景中使用备忘录模式(比如一个for 循环中)

# 访问者模式

封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作

使用场景：

-   一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景
-   需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类

# 状态模式

当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类

使用场景：

-   行为随状态改变而改变的场景，这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式
-   条件、分支判断语句的替代者

# 解释器模式

给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子

使用场景：

-   重复发生的问题可以使用解释器模式
-   一个简单语法需要解释的场景

注意： 尽量不要在重要的模块中使用解释器模式，否则维护会是一个很大的问题。在项目中可以使用 shell、JRuby、Groovy 等脚本语言来代替解释器模式，弥补 Java 编译型语言的不足。

# 享元模式

使用共享对象可有效地支持大量的细粒度的对象。对象的信息分为两个部分：内部状态与外部状态

使用场景：

-   系统中存在大量的相似对象
-   细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份
-   需要缓冲池的场景

注意：

-   享元模式是线程不安全的，只有依靠经验，在需要的地方考虑一下线程安全，在大部分场景下不用考虑。对象池中的享元对象尽量多，多到足够满足为止
-   性能安全：外部状态最好以java的基本类型作为标志，如String，int，可以提高效率

# 桥梁模式

将抽象和实现解耦，使得两者可以独立地变化

使用场景：

-   不希望或不适用使用继承的场景
-   接口或抽象类不稳定的场景
-   重用性要求较高的场景 

注意：发现类的继承有N层时，可以考虑使用桥梁模式。桥梁模式主要考虑如何拆分抽象和实现
