### 1. **策略模式的核心思想是什么？请简要解释它在这个系统中的应用。**

**答案**： 策略模式（Strategy Pattern）是一种行为设计模式，它定义了一系列算法（策略），并将每一个算法封装起来，使得它们可以互相替换。策略模式允许客户端在运行时选择不同的策略，而不需要修改客户端代码。

在这个系统中，`StrategyHandler` 接口和其实现类（如 `RootNode`、`SwitchRoot`）实现了策略模式。`DefaultActivityStrategyFactory` 作为工厂，负责创建具体的策略处理器（例如 `RootNode`）。根据市场产品数据，系统可以动态地选择不同的策略来执行不同的业务逻辑，从而使得业务逻辑更灵活、可扩展。

### 2. **`DefaultActivityStrategyFactory` 类是如何工作的？它的作用是什么？**

**答案**： `DefaultActivityStrategyFactory` 是一个工厂类，用于创建并提供一个具体的策略处理器实例。在这个系统中，它返回一个 `RootNode` 实例，该实例实现了 `StrategyHandler` 接口，并负责处理团购市场的试算服务。它的主要作用是将业务逻辑的实现和调用分离，客户端通过 `strategyHandler()` 方法可以获取到具体的策略执行器（即 `RootNode`），然后执行具体的业务逻辑。

### 3. **`RootNode` 类的作用是什么？它如何利用策略模式执行业务逻辑？**

**答案**： `RootNode` 是策略模式中的一个具体策略类，它实现了 `StrategyHandler` 接口。其主要作用是处理团购市场的具体业务逻辑。通过重写 `doApply()` 和 `get()` 方法，`RootNode` 定义了如何执行实际的业务逻辑（例如拼团商品查询试算）和如何选择下一个策略（通过 `get()` 方法）。它从 `DefaultActivityStrategyFactory` 获取，并且可能与其他节点（如 `SwitchRoot`、`MarketNode`）合作，依赖于具体的市场产品和动态上下文来执行不同的策略。

### 4. **请描述 `IndexGroupBuyMarketServiceImpl` 类的功能。它如何与其他类协作？**

**答案**： `IndexGroupBuyMarketServiceImpl` 是服务层的实现类，负责调用具体的策略逻辑来处理团购市场的试算。它通过 `DefaultActivityStrategyFactory` 获取一个策略处理器（即 `RootNode`），然后将 `MarketProductEntity` 和 `DynamicContext` 传递给该策略处理器，通过 `apply()` 方法执行具体的业务逻辑。最终，`IndexGroupBuyMarketServiceImpl` 会返回 `TrialBalanceEntity`，即试算结果。

该类与 `DefaultActivityStrategyFactory` 和 `RootNode` 等类协作，使用策略模式处理不同的业务需求，并通过接口的方式解耦不同组件的关系。

### 5. **`doApply` 方法和 `multiThread` 方法有什么区别？它们分别处理什么？**

**答案**：

**`doApply` 方法**：这是一个业务处理方法，通常会处理具体的业务逻辑（如试算、价格计算等）。在 `RootNode` 类中，`doApply()` 实现了具体的业务逻辑，在执行策略时进行必要的业务计算。



**`multiThread` 方法**：这是一个异步数据加载方法，通常用于处理需要并行处理的数据或任务。`multiThread` 方法在某些场景下会用来并行加载必要的数据或执行异步任务，以提高系统性能。在 `AbstractMultiThreadStrategyRouter` 中，`multiThread()` 是一个抽象方法，具体的实现由子类决定（例如在 `RootNode` 类中）。

### 6. **在这个系统中，如何使用多线程提高性能？你如何优化 `multiThread` 方法？**

**答案**： 多线程的使用通常用于提高系统的并发能力，特别是在需要处理多个独立任务时。`multiThread` 方法可以用于并行加载数据或并行执行多个异步任务，避免阻塞主线程，提高系统的吞吐量和响应时间。

优化建议：

**任务分解**：将复杂的任务分解为多个独立的子任务，然后通过线程池并行处理这些子任务。



**线程池管理**：避免创建过多的线程导致系统资源耗尽，使用线程池（如 `ExecutorService`）来管理线程，确保系统的稳定性。



**异常处理**：确保多线程操作中的异常能够被捕获并适当处理，避免线程异常导致程序崩溃。

### 7. **如果你需要为 `RootNode` 添加一个新的业务逻辑，应该如何扩展这个系统？**

**答案**： 为了添加一个新的业务逻辑，可以按照以下步骤进行扩展：



**创建新的节点类**：如果新业务逻辑需要不同的处理，可以创建一个新的节点类（例如 `NewBusinessNode`），它实现 `StrategyHandler` 接口，并重写 `doApply()` 和 `get()` 方法。



**修改 `DefaultActivityStrategyFactory`**：根据需要，可以在 `DefaultActivityStrategyFactory` 中返回新的节点类实例（例如 `NewBusinessNode`），而不是 `RootNode`。



**更新服务类**：如果需要将新的业务逻辑集成到服务层（如 `IndexGroupBuyMarketServiceImpl`），可以通过适当的修改让它调用新的策略处理器。



**保持扩展性**：通过策略模式和工厂模式，新的业务逻辑可以很容易地集成到现有框架中，而不需要修改已有代码，保持系统的可扩展性和解耦性。

### 8. **在这种架构中，如何进行单元测试？**

**答案**： 单元测试时，可以利用 **Mocking** 技术来模拟依赖对象。对于 `RootNode`、`StrategyHandler` 和其他依赖的类（如 `DefaultActivityStrategyFactory`），可以使用 `Mockito` 或其他测试框架来进行模拟。

例如：

模拟 `DefaultActivityStrategyFactory`，确保返回一个预定义的策略处理器。



模拟 `MarketProductEntity` 和 `DynamicContext`，为测试提供所需的输入数据。



测试 `indexMarketTrial()` 方法时，验证它是否正确调用了 `apply()` 方法并返回期望的结果。

这样可以确保各个组件在隔离的环境中独立验证其功能，确保系统的健壮性。

### 9. **如何改进系统的可维护性和可扩展性？**

**答案**：

**加强模块化设计**：通过接口和抽象类，确保系统的灵活性，方便以后新增业务逻辑或修改现有逻辑而不影响其他部分。

**统一异常处理**：为多线程操作、业务处理等部分加入统一的异常处理和日志记录，方便后续排查问题。

**增强文档和注释**：通过详细的文档和代码注释，增强系统的可读性和可维护性，帮助其他开发人员理解和扩展系统。

**引入配置化管理**：通过配置文件来管理不同策略的选择和多线程的参数设置，减少硬编码，方便后续的配置调整。

这些措施能够有效提升系统的可维护性和可扩展性



**Limit 1找到就返回，避免全表扫描**

@builder是为类自动生成**建造者模式**

QueryGroupBuyActivityDiscountVOThreadTask queryGroupBuyActivityDiscountVOThreadTask = new QueryGroupBuyActivityDiscountVOThreadTask(requestParameter.getSource(), requestParameter.getChannel(), repository);

FutureTask<GroupBuyActivityDiscountVO> groupBuyActivityDiscountVOFutureTask = new FutureTask<>(queryGroupBuyActivityDiscountVOThreadTask);

threadPoolExecutor.execute(groupBuyActivityDiscountVOFutureTask);



dynamicContext.setGroupBuyActivityDiscountVO(groupBuyActivityDiscountVOFutureTask.get(timeout, TimeUnit.*MINUTES*));





`private Map<String, IDiscountCalculateService> discountCalculateServiceMap;` 是一种 Spring 的Map 注入方式，会根据一个接口把所有的实现类都注入上，之后 Key 是 Bean 的名字



```Java
@Service("MJ")
public class MJCalculateService extends AbstractDiscountCalculateService 
```

标识bean id

```
@Resource
private Map<String, IDiscountCalculateService> discountCalculateServiceMap;
```



2、redis的bitmap，bitmap是基于位的映射，一个byte中占8个bit，每一个bit值表示有或者没有，也就是二进制的0或1，0代表该数值没有出现过，1代表该数值出现过，存储的时候，会比HashMap或者HashSet存储空间要节省32倍。排序和读取的会比较快，时间复杂度方面也是O(Max/n)，（其中Max为byte[]数组的大小，n为线程大小）这样的数据结构，比较适合存储用户标签系统，会对查询的性能进行快速的提升，redis中可以使用bitSet类，使用并存储当前用户的标签。





```
@Configuration
@EnableConfigurationProperties(RedisClientConfigProperties.class)
public class RedisClientConfig {

    @Bean("redissonClient")
    public RedissonClient redissonClient(ConfigurableApplicationContext applicationContext, RedisClientConfigProperties properties) 
    
    
    
@Data
@ConfigurationProperties(prefix = "redis.sdk.config", ignoreInvalidFields = true)
public class RedisClientConfigProperties {
```



课程补充知识（BitMap）：

Redis 的 Bitmap（位图）是一种特殊的数据结构，用于高效地处理位级别的操作。它基于字符串实现，但将字符串视为一个由二进制位组成的数组，每个位只能是 0 或 1。通过 Bitmap，你可以高效地存储和操作大量的布尔值（如标记、状态等）。

**Bitmap 的优势**

1、高效存储：Bitmap 使用二进制位存储数据，非常节省内存。例如，存储 1 亿个布尔值只需要约 12MB 内存。

2、快速操作：Redis 的位操作是基于底层的 C 语言实现，性能非常高。

3、灵活应用：适用于需要标记、统计和查询的场景。

**Bitmap 的应用场景**

1.   用户签到（如淘宝、京东、美团等）都有用户签到功能

使用 Bitmap 记录用户每天的签到情况，偏移量表示日期，值为 1 表示签到，0 表示未签到。

示例：SETBIT sign:user1 365 1，表示用户 user1 在第 365 天签到。

2.   活跃用户统计（如微信、微博、抖音等）需要统计每日、每周或每月的活跃用户数

使用 Bitmap 记录用户的活跃状态，偏移量表示用户 ID，值为 1 表示活跃。

示例：SETBIT active_users 1001 1，表示用户 ID 1001 是活跃用户。

3.   布隆过滤器（Bloom Filter）（如 Google、Facebook、Twitter 等）常用它来解决缓存穿透、垃圾邮件过滤等问题

Bitmap 可以作为布隆过滤器的基础数据结构，用于高效判断某个元素是否存在。

4.   权限管理（如阿里云、腾讯云等）需要管理用户的权限

使用 Bitmap 表示用户的权限，每个位代表一种权限，1 表示有权限，0 表示无权限。



### Entity（实体类）

-   **用途**：负责与数据库交互，承载业务核心数据模型，映射数据库表结构
-   **字段**：和数据库表字段严格一一对应
-   **数据格式**：存储原始数据库数据，无额外加工
-   **生命周期**：贯穿整个业务逻辑层，从数据查询、业务处理到持久化都可能用到
-   **命名规范**：常以 `Entity` 结尾（如 `UserEntity` ），或直接用数据库表名命名

### VO（值对象 / 视图对象）

-   **用途**：面向前端展示或接口返回，聚焦前端所需数据传递
-   **字段**：仅包含前端需要的字段，无需和数据库表完全对应
-   **数据格式**：可对原始数据格式化、加工（如日期转成 “YYYY - MM - DD” 字符串）
-   **生命周期**：主要在展示层（如前端页面渲染）或接口层（给前端返回数据）使用
-   **命名规范**：通常以 `VO` 结尾（如 `UserVO` ）

简单说，Entity 贴近数据库，VO 贴近前端展示，二者通过数据转换解耦数据库结构和前端需求 。



降级(应急)是指在系统负载过高或出现故障时，自动或手动关闭一些非核心功能，以保证核心功能的正常运行。

切量(预防)则是指根据系统负载或用户需求，动态调整系统处理请求的能力，如限流。将新功能或改动**逐步开放给部分用户**

白名单用户测试：在推出新功能或进行用户测试时，通过白名单机制限制只有特定用户或用户组可以访问新功能。



动态变更配置的优势：

1、提高灵活性：允许在运行时根据需要调整配置，快速响应业务需求变化。

2、增强系统的可用性和弹性：在系统负载过高或出现故障时，可以通过动态配置快速调整系统行为，保证核心功能的正常运行。

3、便于管理和维护：集中管理配置信息，减少硬编码带来的风险，方便维护与更新。




实现动态变更配置的技术和方法：

1、配置中心：使用如Nacos、Spring Cloud Config等配置中心，提供集中管理和动态刷新配置的功能。

2、热部署和热更新：通过热部署和热更新技术，实现应用程序在不停机的情况下更新配置和功能。

3、编程语言和框架的支持：许多编程语言和框架提供了动态修改对象属性和配置的功能，如Python的setattr()函数、Java的Spring框架等



@Configuration 是 Spring 框架中用于定义配置类的注解，它表明被注解的类是一个 Bean 定义的源头。



@Configuration 注解的作用

1、标识配置类：@Configuration 注解表明该类是一个配置类，Spring 容器会将其视为 Bean 定义的来源。

2、方法作为 Bean 的定义：在 @Configuration 类中，可以使用 @Bean 注解标记的方法来定义 Spring Beans。每个这样的返回方法都会返回一个适合被 Spring 容器管理的 Bean。

3、提供 Java-based 配置方式：使用 @Configuration，开发者可以通过 Java 代码来管理 Spring Beans，不需要使用 XML 文件。这样使得配置更加类型安全和容易维护。



Spring 如何实现自动创建和管理：自动发现项目中标记了特定注解（如 @Component, @Service, @Repository）的类，并将它们注册为 Spring 的 Bean。采用这种方式，spring可以**自动**在需要时创建对象，而不是传统的手动创建。



Bean 的定义：

无参构造函数（默认或显式声明无参构造器）、私有字段（属性）、公共的 Getter 和 Setter 方法（用于访问/修改属性）、可序列化（通常实现 Serializable 接口，非强制）



被标注为@Configuration，说明它是一个Spring配置类，可能用于定义bean或者处理应用上下文的初始化。同时，它实现了BeanPostProcessor接口，这意味着它会在Spring容器初始化bean之后进行一些处理。

ostProcessAfterInitialization方法，这是BeanPostProcessor的核心方法，会在每个bean初始化之后执行。





步骤:

1.DccValue自定义注解

为什么存在这个注解?

>   *因为想要动态配置降级开关和切量值两个属性,就需要运行时通过反射机制修改属性值,那么反射式如何获取到这两个目标属性值呢?就是通过判断是否存在这个注解,因此这个注解是为了保证目标属性值可以在反射时被扫描到*

2.Dcc配置服务类

>   *存储降级开关和切量属性值,同时需要符合封闭原则暴露取值接口*
>
>   *此处的值需加注解*

3.Dcc配置类

>   *这个类的作用是对DccService中的两个属性值进行初始化,以及配置redis监控器,如果有收到变更值的消息,那么动态修改属性值*
>
>   *对应类中的两个主要方法postProcessAfterInitialization,和dccRedisTopicListener*

4.添加redis的推送controller类

>   *因为更改是以http请求的方式,通过路径参数的形式传递变更值到后台,因此定义controller类*
>
>   *更改值的请求打入项目controller后,内部需要调用redis队列推送,将变更值压入redis的消息队列,然后被3中的redis监控器捕获做属性值更改*

5.switchNode中进行降级,切量逻辑



3.可拓展技术

redis的消息队列机制

bean后置处理器拦截,类似aynsc



**实现过程：** 1.自定义注解DCCValue 2.服务类使用注解 **降级参数downgradeSwitch**表示开关，置为1表示开启降级，服务就不可用了 **切量参数cutRange**表示允许使用服务的用户百分比，通过用户id取哈希值然后对100取模求得其分布的百分比位置，然后和cutRange比较实现限流。 但是求用户百分比分布位置过程相当于是随机的，没办法精确控制用户，所以可以使用**白名单机制** 3.DCCValueBeanFactory动态配置管理的工厂🏭，实现自动的完成属性信息的填充和动态变更操作 postProcessAfterInitialization方法，这是BeanPostProcessor的核心方法，会在每个bean初始化之后执行 实现postProcessAfterInitialization主要完成两个任务： - 配置默认值的检查 - 加载redis中已有的配置更新覆盖掉默认配置 **注意：**先执行构造函数，再postProcessAfterInitialization 会先执行，最后才是 dccRedisTopicListener 的注册和监听。 4.业务使用服务类完成需求 在SwitchNode中提前判断降级、切量 5.启动服务测试验证



在 Java 开发中，`@Repository` 是 Spring 框架提供的一个**原型注解（stereotype annotation）**，主要用于标识**数据访问层（DAO 层）的组件**，其核心作用是：





@Configuration



postProcessAfterInitialization bean初始化后的后置处理



**2-8**



1、@RunWith(SpringRunner.class)

作用：告诉 JUnit 使用 Spring 的测试运行器 执行测试类。

功能：

自动激活 Spring 上下文（ApplicationContext）。

支持 Spring 的测试扩展（如事务管理、MockBean）。



2、@SpringBootTest

作用：标记这是一个 Spring Boot 的集成测试类。

功能：

加载完整的 Spring Boot 应用上下文（自动配置所有组件）。

模拟真实的运行环境（如嵌入式 Tomcat 服务器）。



3、@Resource

作用：将 Spring 容器中的 Bean 注入到当前类中。

与 @Autowired 的区别：

@Resource 默认按 名称 匹配 Bean（name 属性或类名小写形式）。

@Autowired 默认按 类型 匹配 Bean（首选方式）。



4、@RestController 注解

作用：

定义 RESTful 风格的控制器，等同于同时添加了 @Controller 和 @ResponseBody。

自动将方法返回值序列化为 JSON 或 XML（默认 JSON），无需手动处理响应体。

关键特性：

支持 @GetMapping、@PostMapping 等 HTTP 方法注解。

返回值可以是实体类、Map、List 或任何可序列化的对象。



5、@CrossOrigin("*") 注解

作用：

解决跨域资源共享（CORS）问题，允许来自任意域名（*）的客户端访问该接口。

默认配置：

允许所有 HTTP 方法（GET、POST、PUT、DELETE 等）。

允许所有请求头。

允许携带凭证（如 Cookie、Token）。



6、@RequestMapping("/api/v1/gbm/trade/") 注解

作用：

映射基础 URL 路径，该控制器下的所有请求都会以 /api/v1/gbm/trade/ 为前缀。

简化重复路径配置，避免在每个方法上重复写相同的前缀。





MarketTradeControllerTest运行测试方法时，看不太懂怎么调用的方法，问了问AI



步骤 1：Spring 容器启动

当运行测试类时，SpringRunner 会触发 Spring Boot 的自动配置：

扫描所有包（默认从主应用类所在包开始）。

注册所有被 @Component、@Service、@Repository、@Controller 标记的类为 Bean。

建立 Bean 之间的依赖关系（如 IMarketTradeService 的实现类）。



步骤 2：注入 IMarketTradeService

@Resource 注解**会触发 Spring 容器的 依赖查找（会去找实现类）**：

容器中必须存在一个实现了 IMarketTradeService 接口的 Bean。

默认按名称匹配：如果 IMarketTradeService 的实现类名为 MarketTradeServiceImpl，则注入该类。

如果找不到匹配的 Bean，会抛出 NoSuchBeanDefinitionException。

**字段注入**的话：

（@Resource // 字段注入

​    private ITradeRepository repository;）

触发依赖查找，找到具体的实现类（如 TradeRepositoryImpl）并注入到 repository 字段中。

此时不会自动调用实现类的方法，只是完成了字段赋值。

只有调用方法通过 repository 字段访问到 TradeRepositoryImpl 的实例，此时才会执行 TradeRepositoryImpl 中的 save() 方法



步骤 3：调用服务方法

测试类通过注入的 IMarketTradeService 引用，**直接调用**其业务方法（如 lockMarketPayOrder）。

服务方法的实现由 Spring 容器管理（如调用数据库、发送消息等）。