## 一、消息中间件概述

### 1. 定义

消息中间件（MQ，Message Queue）是软件间通信的中间件，通过消息传递实现系统解耦、异步处理等功能。

### 2. 核心优势

-   **应用解耦**：系统间通过消息通信，无需直接依赖接口调用，减少耦合度。例如：A 系统产生数据后发送到 MQ，其他系统按需从 MQ 消费，新增或移除系统无需修改 A 系统。
-   **异步处理**：缩短请求响应时间。例如：预约挂号成功后，异步发送短信、推送消息等，主流程无需等待附属操作完成。
-   **流量削峰**：缓冲高并发请求。例如：秒杀场景中，请求先进入 MQ，后端按能力逐步处理，避免服务器过载。
-   **消息分发**：支持一对多、多对多的消息传递，满足广播、定向发送等需求。
-   **日志处理**：高效传输大量日志数据，适配大数据场景。

### 3. 潜在缺点

-   **系统可用性降低**：MQ 故障可能影响依赖它的业务。
-   **系统复杂度增加**：需解决消息一致性、重复消费、可靠性传输等问题。
-   **一致性风险**：若消息消费端处理失败，可能导致数据不一致。

## 二、RabbitMQ 详解

### 1. 基本概念

| 概念            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| **Broker**      | 消息队列服务器实体，管理消息的存储与转发。                   |
| **Exchange**    | 消息交换机，根据路由规则将消息分发到队列。                   |
| **Queue**       | 消息队列载体，存储消息，供消费者获取。                       |
| **Binding**     | 绑定交换机与队列的规则，定义路由关系。                       |
| **Routing Key** | 路由关键字，交换机根据其匹配队列。                           |
| **VHost**       | 虚拟主机，隔离不同用户的权限与资源（队列、交换机等）。       |
| **Producer**    | 消息生产者，负责发送消息到 MQ。                              |
| **Consumer**    | 消息消费者，从 MQ 获取并处理消息。                           |
| **Channel**     | 消息通道，基于 TCP 连接的虚拟连接，减少 TCP 创建 / 销毁开销，支持多线程独立通信。 |

### 2. 交换器类型

-   **fanout**：广播消息到所有绑定的队列，忽略 Routing Key。
-   **direct**：仅将 Routing Key 与 Binding Key 完全匹配的消息投递到对应队列。
-   **topic**：支持通配符匹配（`*`匹配单个单词，`#`匹配多个单词），灵活路由消息。例如：`order.*`可匹配`order.create`、`order.pay`。
-   **headers**：根据消息头属性匹配，性能差，较少使用。

### 3. 消息可靠性保证

#### （1）发送方确认机制

-   将信道设为`confirm`模式，每条消息分配唯一 ID。
-   消息被投递到目标队列或写入磁盘（持久化消息）后，MQ 返回`ack`（确认）；若丢失，返回`nack`（未确认）。
-   异步回调处理确认结果，生产者可继续发送消息，不阻塞。

#### （2）接收方确认机制

-   消费者需手动确认消息（默认自动确认，需改为手动），确认后 MQ 才删除消息。
-   特殊情况：
    -   消费者未确认且断开连接：MQ 将消息重新分发给其他消费者（可能重复消费，需业务去重）。
    -   消费者未确认且连接未断：MQ 认为其繁忙，不再分配新消息。

#### （3）消息持久化

-   前提：交换机、队列的`durable`属性设为`true`（持久化）。
-   消息需设置 “投递模式” 为 2（持久化），并发送到持久交换机，最终进入持久队列。
-   MQ 将持久化消息写入磁盘日志，重启后自动恢复。

### 4. 高可用方案

#### （1）集群

-   多个节点组成集群，扩展吞吐量，元数据（队列配置等）在节点间同步，但队列数据仅存于单个节点。
-   需配合负载均衡器（如 HAProxy）实现客户端连接分发。

#### （2）镜像队列

-   将队列复制到多个节点，消息主动同步，避免单节点故障导致数据丢失。
-   缺点：节点间同步占用大量网络带宽。

### 5. 常见问题及解决

#### （1）消息积压

-   处理步骤

    ：

    1.  修复消费者问题，暂停现有消费者。
    2.  新建 10 倍分区的 Topic 和临时队列（数量为原 10-20 倍）。
    3.  开发临时消费者，将积压消息均匀分发到临时队列。
    4.  征用 10 倍机器部署消费者，快速消费临时队列消息。
    5.  消费完成后恢复原架构。

#### （2）消息丢失

-   发送方：启用`confirm`模式，确保消息到达 MQ。
-   MQ 端：开启持久化（交换机、队列、消息均持久化）。
-   消费方：手动确认消息，处理完成后再确认。
-   丢失后补救：批量查询丢失数据并重导至 MQ。

#### （3）重复消费

-   生产端：MQ 生成`inner-msg-id`，避免重复入队。
-   消费端：基于业务唯一标识（如订单 ID）去重，确保幂等处理（如查询数据库是否已处理）。

#### （4）消息顺序性

-   将需有序的消息发送到同一队列，且仅用一个消费者处理该队列。
-   消息体内添加全局有序标识辅助排序。

## 三、RocketMQ 详解

### 1. 基本架构

-   **NameServer**：无状态节点，管理 Topic 路由信息，与 Broker 保持长连接，支持集群部署（节点间无信息同步）。
-   **Broker**：存储与转发消息，分 Master 和 Slave，支持多主多从。Master 处理写入，Slave 同步数据（同步双写 / 异步复制）。
-   **Producer**：消息生产者，集群部署，通过 NameServer 获取路由，向 Master 发送消息（支持同步、异步、单向发送）。
-   **Consumer**：消息消费者，集群部署，从 Master/Slave 消费，支持集群消费（分摊消息）和广播消费（全量消费）。

### 2. 核心功能

#### （1）分布式事务消息

-   基于 “半消息” 机制：
    1.  生产者发送半消息（暂不可消费）到 Broker。
    2.  执行本地事务，完成后向 Broker 发送`Commit`（消息可消费）或`Rollback`（消息丢弃）。
    3.  若 Broker 未收到确认，定时回查生产者事务状态，再决定消息处理方式。

#### （2）定时 / 延迟消息

-   支持特定级别延迟（如 5s、10s、1min），消息发送到 Broker 后，到达指定时间才允许消费。

#### （3）消息过滤

-   基于 Tag 过滤：消费者订阅时指定 Tag，Broker 仅投递匹配的消息。
-   建议在消费端过滤，减少 Broker 压力。

#### （4）负载均衡

-   **生产者**：通过`MQFaultStrategy`选择 Broker，避免重复选择失败节点。
-   **消费者**：基于队列分配算法（如平均分配、环形分配），将消息队列分摊给消费组内实例。

### 3. 消息可靠性

-   **发送方**：同步 / 异步发送确保消息到达 Broker，失败重试。

-   Broker

    ：

    -   刷盘策略：同步刷盘（消息写入磁盘后返回确认）、异步刷盘（写入内存后返回，后台异步刷盘）。
    -   主从复制：同步双写（Master 与 Slave 均写入成功才返回）、异步复制（Master 写入后即返回，异步同步至 Slave）。

-   **消费方**：维护消费偏移量（`offset`），处理成功后提交`offset`，失败则重试。

### 4. 消息堆积

-   消息持久化到磁盘，Broker 定期清理过期数据（如保留 3 天），支持亿级消息堆积。
-   堆积后性能：通过索引与数据分离存储，减少 IO 开销，保证消费吞吐量。

## 四、消息中间件对比

| 特性       | ActiveMQ             | RabbitMQ             | RocketMQ         | Kafka                          |
| ---------- | -------------------- | -------------------- | ---------------- | ------------------------------ |
| 开发语言   | Java                 | Erlang               | Java             | Scala                          |
| 单机吞吐量 | 万级                 | 万级                 | 10 万级          | 10 万级                        |
| 时效性     | ms 级                | us 级（延迟最低）    | ms 级            | ms 级以内                      |
| 可用性     | 高（主从）           | 高（主从）           | 极高（分布式）   | 极高（分布式）                 |
| 功能特性   | 协议支持全，文档丰富 | 并发强，管理界面友好 | 功能完善，可定制 | 适合大数据日志场景，功能较简单 |

### 选型建议

-   中小型公司：优先 RabbitMQ（易管理，高并发）。
-   大型公司：可选 RocketMQ（高吞吐，可定制）。
-   大数据日志场景：首选 Kafka。

## 五、总结

-   消息中间件通过解耦、异步、削峰等能力提升系统灵活性与稳定性，但需解决可靠性、一致性等问题。
-   RabbitMQ 适合中小规模场景，优势在于低延迟和丰富的管理功能；RocketMQ 适合大规模分布式场景，支持复杂事务与高吞吐。
-   实际应用中需根据业务场景（如吞吐量、可靠性要求、功能需求）选择合适的中间件，并设计对应的容错方案。