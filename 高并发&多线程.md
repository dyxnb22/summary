>   Java内存模型 JMM

定义了程序中各种变量的访问规则。其规定所有变量都存储在主内存，线程均有自己的工作内存

工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存

>   as-if-serial 保证单线程执行结果不变

编译器等会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果和用户原始程序输出预定结果一致

>   Happens-before 保证多线程执行结果不变

程序次序规则：一个线程内写在前面的操作先行发生于后面的

锁定规则：unlock 操作先行发生于后面对同一个锁的lock 操作

volatile 规则：对 volatile 变量的写操作先行发生于后面的读操作

线程启动规则：线程的 start 方法先行发生于线程的每个动作

线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

线程终止规则：线程中所有操作先行发生于对线程的终止检测

对象终结规则：对象的初始化先行发生于 finalize 方法

传递性规则：如果操作 A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作 C

>   线程的可见性

当一个线程修改共享变量时，其他线程能够立即得知修改。volatile, synchronized, final都能保证可见性

>   有序性

虽然多线程存在并发和指令优化等操作，在本线程内观察该线程的所有执行操作是有序的

>   volatile

1.   保证变量对所有线程的可见性
2.   禁止指令重排序优化。使用volatile 变量进行写操作，汇编指令带有lock 前缀，相当于一个内存屏障，编译器不会将后面的指令重排到内存屏障之前

>   Java线程实现方式

1.   实现Runnable接口
2.   继承Thread类
3.   实现Callable接口

>   Java线程状态

NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法

RUNNABLE：运行状态。其表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU

BLOCKED：阻塞状态。线程等待获取锁，锁还没获得

WAITING：等待状态。线程内run方法运行完语句Object.wait() / Thread.join()进入该状态

TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) / Object.wait(long) /

Thread.join(long)进入状态。其中这些参数代表等待的时间

TERMINATED：结束状态。线程调用完run方法进入该状态

>   线程通信

1.   volatile 关键词修饰变量，保证所有线程对变量访问的可见性
2.   synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中
3.   wait/notify方法
4.   IO通信

>   线程池

没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后执行接下来任务，复用已创建的线程，降低开销、控制最大并发数

线程池创建线程时，会将线程封装成工作线程Worker，Worker 在执行完任务后还会循环获取工作队列 中的任务来执行。 将任务派发给线程池时，会出现以下几种情况

1.   核心线程池未满，创建一个新的线程执行任务
2.   如果核心线程池已满，工作队列未满，将线程存储在工作队列
3.   如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务
4.   如果超过大小线程数，按照拒绝策略来处理任务

>   线程池参数

1.   corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁
2.   maximumPoolSize：线程池能够容纳同时执行的线程最大数
3.   keepAlive Time：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePooISize 个线程为止，避免浪费内存资源
4.   workQueue： 工作队列
5.   threadFactory：线程工厂，用来生产一组相同任务的线程
6.   handler： 拒绝策略。有以下几种拒绝策略：
     -   AbortPolicy：丢弃任务并抛出异常
     -   CallerRunsPolicy： 重新尝试提交该任务
     -   DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列
     -   DiscardPolicy 表示直接抛弃当前任务但不抛出异常。

>   线程池创建方法

1.   newFixedThreadPool，创建固定大小的线程池
2.   newSingleThreadExecutor，使用单线程线程池
3.   newCachedThreadPool,maximumPooISize 设置为 Integer 最大值，工作完成后会回收工作线程
4.   newScheduledThreadPool：支持定期及周期性任务执行，不回收工作线程
5.   newWorkStealingPool：一个拥有多个任务队列的线程池。

>   线程池状态

-   Running：能接受新提交的任务，也可以处理阻塞队列的任务
-   Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown方法，会进入该状态
-   stop：不接受新任务，不处理存量任务，调用shutdownnow进入该状态
-   Tidying：所有任务已经终止了，worker_count(有效线程数)为0
-   Terminated：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态

>   Executor框架

Executor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的Execute方法就可以提交任务。产生线程池的函数ThreadPoolExecutor也是Executor的具体实现类

>Executor继承关系

-   Executor：一个接口，其定义了一个接收Runnable对象的方法executor，该方法接收一个Runable 实例执行这个任务
-   ExecutorService:Executor的子类接口，其定义了一个接收Callable对象的方法，返回 Future 对象，同时提供execute方法
-   ScheduledExecutorService：ExecutorService的子类接口，支持定期执行任务
-   AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现
-   Executors：实现ExecutorService接口的静态工厂类，提供了一系列工厂方法用于创建线程池
-   ThreadPoolExecutor：继承AbstractExecutorService，用于创建线程池
-   ForkJoinPool：继承AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于map reduce
-   ThreadPoolExecutor：继承ThreadPoolExecutor，实现ScheduledExecutorService，用于创建带定时任务的线程池

>   阻塞队列

阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻 塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：

-   ArrayBlockingQueue：底层是由数组组成的有界阻塞队列
-   LinkedBlockingQueue： 底层是由链表组成的有界阻塞队列
-   PriorityBlockingQueue：阻塞优先队列
-   DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素
-   SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作
-   LinkedTransferQueue：与LinkedBlockingQueue相比多一个transfer方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者
-   LinkedBlockingDeque：双向阻塞队列

>   ThreadLocal

ThreadLocal 是线程共享变量。ThreadLocal有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的

-   set 给ThreadLocalMap设置值
-   get 获取ThreadLocalMap
-   remove 删除ThreadLocalMap类型的对象

存在的问题

1.   对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal也会被重用， 造成一系列问题
2.   内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的value是强引用，因此当ThreadLocal被垃圾回收后，value 依旧不会被释放，产生内存泄漏

>   Java并发包下unsafe类

Java 有个类叫 unsafe类，这个类类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础

>   乐观锁和CAS算法

乐观锁：读操作前不上锁，写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。像数据库提供的类似于 write_condition 机制和  java.util.concurrent.atomic 包下面的原子变量类

一般都采用Compare And Swap(CAS，读取变量值和旧值比较，相等则修改，不等则不操作，自旋锁不断重试)和版本号(ABA问题，JDK1.5以后的 AtomicstampedReference 类就提供了此种能力)进行实现

>   悲观锁

把数据锁住再对数据进行读写。一般数据库本身锁的机制都是基于悲观锁的机制实现，以及Java 中 synchronized 和 ReentrantLock等独占锁

>   常见的Atomic类

在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者-方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便

基本数据类型的原子类：AtomicInteger/Long/Boolean

Atomic数组类型：Atomic[Integer/Long/Reference]Array

Atomic引用类型：AtomicReference 原子更新引用类型；AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记；AtomicStampedReference 原子更新带有版本号的引用类型

FieldUpdater类型：AtomiclntegerFieldUpdater 原子更新整形字段的更新器；AtomicLongFieldUpdater 原子更新长整形字段的更新器；AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器

>   Atomic类基本实现原理

以Atomiclntger 为例： 

方法getAndIncrement：以原子方式将当前的值加1，具体实现为： 

1.   在 for 死循环中取得 Atomiclnteger 里存储的数值
2.   对 AtomicInteger 当前的值加1
3.   调用 compareAndSet 方法进行原子更新
4.   先检查当前数值是否等于 expect
5.   如果等于则说明当前值没有被其他线程修改，则将值更新为 next
6.   如果不是会更新失败返回 false，程序会进入 for 循环重新进行compareAndSet 操作

>   CountDownLatch

countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用 countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。 只能一次性使用，不能reset。

>   CyclicBarrier

类似CountDownLatch，但是其可以重复使用

>   Semaphore

Semaphore即信号量

Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0，线程进入休眠。

>   Exchanger

Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换

>   Synchronized底层实现原理

Java 对象底层都关联一个的 monitor，使用 synchronized 时JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者， monitor 在被释放前不能再被其他线程获取

synchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法， 锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象

执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁， 就把锁的计数器加1，执行 monitorexit 指令时会将锁计数器减1。一旦计数器为0锁随即就被释放

>   Synchronized关键词使用方法

1.   直接修饰某个实例方法
2.   直接修饰某个静态方法
3.   修饰代码块

>   在Java 中Lock接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？

Lock 接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，满足你写像 ConcurrentHashMap这样的高性能数据结构和有条件的阻塞

>   Java偏向锁

JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。 其申请流程內： 

1.   首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。 否则继续下一步判断
2.   判断目前请求锁的线程ID 是否和偏向锁本身记录的线程ID一致。如果一致，继续下一步的判断， 如果不一致，跳转到步骤4
3.   判断是否需要重偏向。如果不用的话，直接获得偏向锁
4.   利用CAS 算法将对象的 Mark Word 进行更改，使线程ID 部分换成本线程ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁

>   轻量级锁

轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。 其申请流程为： 

1.   如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝
2.   虚拟机使用 CAS 尝试把对象的Mark Word 更新为指向锁记录的指针
3.   如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态
4.   如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧
5.   如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行
6.   如果不是则说明锁对象已经被其他线程抢占
7.   如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞

>   锁优化策略

自适应自旋、锁消除、锁粗化、锁升级

>   java的自旋锁

线程获取锁失败后，不放弃CPU，不停重试

>   自适应自旋锁 

自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定

>   简述锁粗化

扩大加锁范围，避免反复的加锁和解锁

>   简述锁消除

是一种更为彻底的优化，在编译时，java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁

>   Lock与ReentrantLock

Lock 接口是java并发包的顶层接口

可重入锁 ReentrantLock 是Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降

>   AQS

AQS(AbstractQuenedSynchronizer) 抽象的队列式同步器。 AQS是将每—条请求共享资源的线程封装成一个锁队列的一个结点(Node)，来实现锁的分配。 AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。 子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改

>   AQS获取/释放独占锁独占锁原理

获取：

1.   调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋
2.   调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞

释放：

1.   调用 tryRelease 方法释放同步状态
2.   调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态

>   AQS获取/释放共享锁独占锁原理

获取: 调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于0表示能获取同步状态

释放: 释放，并唤醒后续处于等待状态的节点

# 并发

>   现在有T1、T2、T3三个线程，你怎样保证T2在T1 执行完后执行，T3在T2执行完后执行？ 

join方法

>   在java 中 wait 和 sleep 方法的不同

等待时 wait 会释放锁，而 sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行

>   用Java 实现阻塞队列

使用wait notify

>   用Java 写代码来解决生产者——消费者问题

