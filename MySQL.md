# Mysql基本概念

>   Mysql的技术特点

Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具

>   Mysql的默认端口

3306

>   和Oracle相比Mysql的优势

Mysql 是开源软件，便携式的，带有命令提示符的GUI，使用 Mysql 查询浏览器支持管理

>   数据库三大范式

-   第一范式：表中的所有字段值都**是不可分解的原子值**
-   第二范式：关系模式必须满足第一范式，并且**所有非主属性都完全依赖于主键**
-   第三范式：关系模型满足第二范式，所有非主属性对任何候选关键字都**不存在传递依赖**

>   MySQL架构

应用层：负责和客户端，响应客户端请求，建立连接，返回数据
逻辑层：包括SQK接口，解析器，优化器，Cache与buffer
数据库引擎层：有常见的MyISAM,InnoDB等
物理层：负责文件存储，日志等

>   Mysql组成部分

1.   Server 
     -   连接器：管理连接，权限验证
     -   分析器：词法分析，语法分析
     -   优化器：执行计划生成，索引的选择
     -   执行器：操作存储引擎，返回执行结果
2.   存储引擎：存储数据，提供读写接口

>   Mysql优化

-   SQL语句及索引的优化
-   数据库表结构的优化
-   系统配置的优化
-   硬件的优化

>   federated 表是什么

允许访问位于其他服务器数据库上的表

>   批处理模式

mysql

mysql mysql.out

>   解释访问控制列表

ACL(访问控制列表)是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。 Mysql 将ACL(也称为授权表)缓存在内存中。当用户尝试认证或运行命令时，Mysql 会按照预定的顺序检查 ACL 的认证信息和权限

>   Mysql数据表在什么情况下容易损坏

服务器突然断电导致数据文件损坏
强制关机，没有先关闭 mysql 服务等

>   视图的作用

视图是虚拟的表，只包含使用时动态检索数据的查询，不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节， 保护数据；视图创建后，可以使用与表相同的方式利用它们

视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有 order by 则对视图再次 order by 将被覆盖。 

对于某些视图比如未使用联结子查询分组聚集函数 Distinct Union 等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新

>   drop delete 和 truncate的区别

-   drop 直接删掉表

    truncate 删除表中数据，再插入时自增长id又从1开始。并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

    delete 删除表中数据，每次删除一行，并将删除操作作为事务记录到日志里保存以便进行回溯

-   表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间 会恢复到初始大小，而DELETE 操作不会减少表或索引所占用的空间。drop 语句将表所占用的空间全释放掉

-   一般而言，drop > truncate > delete

-   应用范围。TRUNCATE 只能对 TABLE；DELETE 可以是 table 和 view

-   truncate 与不带 where 的delete ：只删除数据，而不删除表的结构；drop 语句将删除表的结构被依赖的约束，触发器、索引；依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid

-   delete 语句 DML，这个操作会被放到rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发。truncate、drop 是 DLL，操作立即生效，原数据不放到 rollback segment 中，不能回滚

-   在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete 且注意结合where 来约束影响范围。回滚段要足够大。要删除表用drop； 若想保留表而将表中数据删除，如果与事务无关，用 truncate 即可实现。如果和事务有关，或想触发 trigger，还是用 delete

-   Truncate table 表名速度快，而且效率高，因为：truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。 DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放

-   对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器

# Mysql存储引擎

存储类型也称为表类型，数据使用各种技术存储在文件中

>   MySQL中有哪些不同的表格

共有5种类型的表格：1、MyISAM 2、Heap 3、Merge 4、INNODB 5、MISAM

>   简述InnoDB存储引擎

InnoDB是MySQL的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁， 支持外键，适合数据增删改查都频繁的情况。 InnoDB 采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 REPEATABLE READ，并通过间隙锁策略防止幻读，间隙锁使InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入

>   简述MyISAM存储引擎

 MySQL5.1及之前，MyISAM 是默认存储引擎。MyISAM不支持事务，支持表级锁，不支持行级锁，不支持外键，该存储引擎存有表的行数，count运算会更快。适合查询频繁，不适合对于增删改要求高的情况

>   ISAM

ISAM 简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储 和检索数据

>   myisamchk 是用来做什么的

它用来压缩 MyISAM 表，减少磁盘或内存使用

>   MyISAM Static和MyISAM Dynamic 有什么区别

在 MyISAM Static 上的所有字段有固定宽度。动态MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。 MyISAM Static 在受损情况下更容易恢复

>   Mysql存储缓存的弊端

查询缓存可能会失效非常频繁，对于一个表，只要有更新，该表的全部查询缓存都会被清空。因此对于频繁更新的表来说，查询缓存不一定能起到正面效果。对于读远多于写的表可以考虑使用查询缓存

8.0版本的查询缓存功能被删除

>   myisamchk 是用来做什么的

用来压缩 MyISAM 表，这减少了磁盘或内存使用

>   Heap表概念

HEAP 表存在于内存中，用于临时高速存储

Heal 表的大小可通过称为 max_heap_table_size 的Mysql 配置变量来控制

-   BLOB 或TEXT字段是不允许的
-   只能使用比较运算符
-   HEAP 表不支持 AUTO_INCREMENT
-   索引不可为 NULL

>   MyISAM和InnoDB的区别

-   InnoDB支持事务，MyISAM不支持，但是每次查询都是原子的

-   InnoDB支持行级锁，MyISAM支持表级锁

-   InnoDB支持多版本并发控制(MVCC)，MyISAM不支持

-   InnoDB支持外键，MyISAM不支持

-   MyISAM支持全文索引，InnoDB部分版本不支持(但可以使用Sphinx插件)

-   MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址，InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值

-   MyISAM数据以文件方式存储，移植备份恢复方便，可以针对单独某张表；InnoDB使用拷贝数据文件、备份binlog，或者使用mysqldump

-   一个MyISAM有三个文件，表结构文件 .frm。数据文件 .MYD(MYData)，索引文件.MYI(MYIndex)，非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。

    一个 InnoDb 引擎存储在一个文件空间(共享表空间，表大小不受操作系统控制， 一个表可能分布在多个文件里)，也有可能为多个(设置为独立表空，表大小受操作系统文件大小限制，一般为 2G)，受操作系统文件大小的限制。主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从 辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据 时，为维持 B+树结构，文件的大调整。

>   简述Memory存储引擎

Memory存储引擎将所有数据都保存在内存，不需要磁盘IO。支持哈希索引，因此查找速度极快。 Memory 表使用表级锁，因此并发写入的性能较低

# 索引

>   可以使用多少列创建索引

 任何标准表最多可以创建16个索引列

>   索引类型

-   数据结构角度 B-Tree索引  哈希索引  R-Tree索引  全文索引
-   物理存储角度 主键索引(聚簇索引)：叶子节点存的是整行的数据 
                            非主键索引(二级索引)：叶子节点存的主键的值

>   建立索引原则

在最频繁使用的、用以缩小查询范围的字段上建立索引。在频繁使用的、需要排序的字段上建立索引 

什么情况下不宜建立索引？ 

对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。对于一些特的数据类型，不宜建立索引，比如文本字段(text)等

>   常用索引

普通索引，唯一任务是加快对数据的访问速度

唯一索引(唯一，允许null，UNIQUE)

主键索引(唯一，不允许null，PRIMARY KEY)

组合索引

索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件

>   唯一索引一定比普通索引快吗

唯一索引不一定比普通索引快，还可能慢

1.   查询时，在未使用limit 1的情况下，在匹配到一条数据后，唯一索引即返回，普通索引会继续匹配下一条数据，发现不匹配后返回。如此看来唯一索引少了一次匹配，但实际上这个消耗微乎其微
2.   更新时，这个情况就比较复杂了。普通索引将记录放到 change buffer 中语句就执行完毕了。而对唯一索引而言，它必须要校验唯一性，因此，必须将数据页读入内存确定没有冲突，然后才能继续操作。对于写多读少的情况，普通索引利用 change buffer 有效减少了对磁盘的访问次数，因此普通索引性能要高于唯一索引

>   Mysql索引相关优化

-   尽量使用主键查询：聚簇索引上存储了全部数据，相比普通索引查询，减少了回表的消耗
-   MySQL5.6之后引入了索引下推优化，通过适当的使用联合索引，减少回表判断的消耗
-   若频繁查询某一列数据，可以考虑利用覆盖索引避免回表
-   联合索引将高频字段放在最左边

>   什么情况索引设置了但无法使用

-   以"%"开头的 LIKE 语句，模糊匹配
-   OR 语句前后没有同时使用索引
-   数据类型出现隐式转化(如varchar 不加单引号的话可能会自动转换为int型)

# 查询优化



# 锁

>   MySQL的共享锁和排它锁

共享锁也称为读锁，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰

排他锁也称为写锁，会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源

>   MySQL中的按粒度的锁分类

-   表级锁：实现简单，开销小，加锁快，不会出现死锁，锁力度大，但并发能力低，容易锁冲突
-   行锁：加锁粒度最小，并发度高，发生锁冲突概率最低，但加锁的开销也最大，加锁慢，会出现死锁。如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么InnoDB会创建一个隐藏的聚簇索引加锁
-   Gap 锁：也称为间隙锁：锁定一个范围但不包括记录本身。防止幻读
-   Next-key Lock： 行锁+gap锁
-   页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

>   如何解决数据库死锁

1. 预先检测到死锁的循环依赖，并立即返回一个错误
2. 当查询的时间达到锁等待超时的设定后放弃锁请求

>   锁的优化

1.   读写分离
2.   分段加锁
3.   减少锁持有的时间
4.   多个线程尽量以相同的顺序去获取资源，不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁

>   索引底层原理

B+树，因此InnoDB 建议为大部分表使用默认自增的主键作为主索引

>   B-Tree与B+树

B-Tree 是一种自平衡的多叉树。每个节点都存储关键字值。其左子节点的关键字值小于该节点关键字 值，且右子节点的关键字值大于或等于该节点关键字值。 
B+树也是是一种自平衡的多叉树。其基本定义与B树相同，不同点在于数据只出现在叶子节点，所有叶子节点增加了一个链指针，方便进行范围查询。 B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，访问叶子节点上关联的数 据也具有更好的缓存命中率。并且数据顺序排列并且相连，所以便于区间查找和搜索。 B树每一个节点都包含key和value，查询效率比B+树高

# MySQL日志



# 主从复制



# MySQL配置和性能调优

>   性能分析的方法

show status
Bytes_received和Bytes_sent 和服务器之间来往的流量
Com_*服务器正在执行的命令
Created_*在查询执行期限间创建的临时表和文件
Handler_*存储引擎操作
Select_*不同类型的联接执行计划
Sort_*几种排序信息。
Show session status like 'Select'
Show profiles
SET profiling=1
Show profiles\G

# Mysql 语法

~~~mysql
# 连接数据库 连接本机不用填主机地址
mysql -h 主机地址 -u 用户名 -p 用户密码
# 修改用户密码
mysqladmin -u 用户名 -p 旧密码 password 新密码
# 新增用户
grant 命令内容 on 数据库.* to 用户名@登录主机 identified by "密码"
# 创建数据库
create database <数据库名>
# 显示数据库
show databases
# 删除数据库
drop database [if exists] <数据库名>
# 使用数据库
use <数据库名>
# 当前连接的数据库
select database();
select version(); # 显示mysql版本
select now(); #显示当前时间
select dayofmonth(current_date); #显示年月日
select month(current_date);
select year(current_date);
select “acsa”; #显示字符串
select 1+3 #当计算器用
select concat(a,"",b) as name from table1 where ... # 串接字符串
# 创建数据库表
create table<表名>
(
  字段名1,数据类型 [列级别约束条件][默认值]
  ...
  [表级别约束条件]
);
# 获取表结构
show tables;
desc 表名
show create table 表名 #显示建表语句
# 删除数据表
drop table [if exits] 表1,表2...;
# 向表中插入数据
insert into 表名 values(值1,值2...)
insert into 表名(列1,列2...) values(值1,值2...)
# 查询表中数据
select 字段列表 from 表1, 表2... where ... group by ... having ... order by ... limit ...
# 删除记录
delete from table_name [where<condition>];
# 修改表中数据
update 表名 set colum_1 = value1 ... where ...;
# 增加字段
alter table 表名 add 新字段 数据类型 约束条件 [first | after 已经存在字段名]
# 修改表名 to加不加都不影响
alter table<旧表名> rename[to]<新表名>;
# 备份数据库
mysqldump -u user -h host -p password dbname[tbname,[tbname...]]>filename.sql
# 还原数据库
mysql -u user -p [dbname]<filename.sql
source filename.sql # 已经登录数据库的情况
# 快速恢复数据库
chown -R mysql.mysql /var/../dbname
cp -R /.../ usr/local/mysql/data
# 查看表中所有索引
show index from <tablename>;
~~~

>   SQL包括哪几个部分

DDL、DML、DCL、DQL

>   数据类型优先级

字段类型优先级：整形>date,time>enum,char>varchar>blob,text 

优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型

>   如何输入十六进制

可以输入带有单引号的十六进制数字和前缀(X)，或者 只用(Ox)前缀输入十六进制数字。 如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串

>   记录货币的字段

numeric 或者 decimal，例如 salary(9,2)

>   ENUM

一个字符串对象，用于指定一组预定义的值，并可在创建表时使用

~~~mysql
create table size (name ENUM('Smail','Medium','Large');
~~~

>   CHAR和VARCHAR的区别

CHAR 列长度固定为创建表时声明的长度，长度值范围是 1到 255。当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格

VARCHAR长度可变

>   float和double的区别

浮点数以8位精度存储在 FLOAT中，并且有四个字节 

浮点数存储在DOUBLE中，精度为18位，有八个字节

>   区分 CHAR_LENGTH 和LENGTH

CHAR_LENGTH 是字符数，而LENGTH 是字节数。Latin 字符的这两个数据是相同的，但是对于 Unicode 和其他编码，它们是不同的

>   NOW()和CURRENT_DATE()有什么区别

NOW()命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE()仅显示当前年份，月份和日期

>   列运算符

=，<>，<=，<，>=，>， <<，>>，<=>，AND，OR 或LIKE 

>   like中% 和 _

%对于0或多个字符，_对于一个

>   如何定义REGEXP

REGEXP 是模式匹配，其中匹配模式在搜索值的任何位置

>   like和regexp的区别

like使用%，regexp使用^

>   MySQL 如何优化DISTINCT

DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a

>   若一张表中只有一个字段 VARCHAR(N)类型，utf8编码，则N最大值为多少？

由于utf8的每个字符最多占用**3**个字节。而MySQL定义行的长度不能超过 65535，因此 N的最大值计算方法：(65535-1-2)/3。减去1的原因是实际存储从第二个字节开始，减去2的原因是因为要在列表长度存储实际的字符长度

>   列的字符串类型

SET, BLOB, ENUM, CHAR, TEXT, VARCHAR

>   BLOB和TETX区别 

BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB，但它们只在容纳的长度有区别

TEXT是一个**不区分大小写**的BLOB。四种 TEXT 类型，同BLOB要求一样(非标准字符串：tinytext, text, mediumtext, longtext)

>   一张表，里面有ID 自增主键，当insert了17 条记录之后，删除了第15,16,17条记录，再把Mysql 重启，再insert一条记录，这条记录的ID 是18还是15 

如果表的类型是MyISAM，那么是18。 因为MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失

如果表的类型是InnoDB，那么是15。 InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失

>   列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况

它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用

>   怎样才能找出最后一次插入时分配了哪个自动增量

LAST_INSERT_ID 将返回由 Auto_increment分配的最后一个值，并且不需要指定表名称

>   Mysql中有关权限的表

user.db, table_priv, columns_priv 和 host。这些表由mysql_intall_db脚本初始化

>   执行SQL语言的过程

1. 客户端首先通过连接器进行身份认证和权限相关
2. 如果是执行查询语句的时候，会先查询缓存，但MySQL 8.0 版本后该步骤移除
3. 没有命中缓存的话，SQL 语句就会经过解析器，分析语句，包括语法检查等
4. 通过优化器，将用户的SQL语句按照 MySQL 认为最优的方案去执行
5. 执行语句，并从存储引擎返回数据

>   Hash索引

哈希索引对于每一行数据计算一个哈希码，并将所有的哈希码存储在索引中，同时在哈希表中保存指向 每个数据行的指针。只有 Memory 引擎显式支持哈希索引。 Hash索引不支持范围查询，无法用于排序，也不支持部分索引列匹配查找

>   自适应Hash索引 

InnoDB对于频繁使用的某些索引值，会在内存中基于 B-Tree 索引之上再创键一个哈希索引

>   聚集索引和稀疏索引

聚集索引按每张表的主键构建一棵B+树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过双向链表连接。表数据访问更快，但表更新代价高。 稀疏索引不会为每个搜索关键字创建索引记录。搜索过程需要，我们首先按索引记录进行操作，并按顺序搜索，直到找到所需的数据为止

>   辅助索引与回表查询

辅助索引是非聚集索引，叶子节点不包含记录的全部数据，包含了一个书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。 通过辅助索引查询，先通过书签查到聚集索引，再根据聚集索引查对应的值，需要两次，也称为回表查询

>   联合索引和最左匹配原则

联合索引是指对表上的多个列的关键词进行索引。 对于联合索引的查询，如果精确匹配联合索引的左边连续一列或者多列，则mysql会一直向右匹配直到 遇到范围查询(>，<，between, like)就停止匹配。MysqI会对第一个索引字段数据进行排序，在第一个字段基础上，再对第二个字段排序

>   覆盖索引

指一个索引包含或覆盖了所有需要查询的字段的值，不需要回表查询，即索引本身存了对应的值 

>   为什么数据库不用红黑树用B+树

红黑树的出度为2，而B Tree 的出度一般都非常大。红黑树的树高h很明显比 B Tree 大非常多，IO次数很多，导致会比较慢，因此检索的次数也就更多。 B+Tree 相比于 B-Tree 更适合外存索引，拥有更大的出度，IO次数较少，检索效率会更高

>   EXPLAIN 关键字

分析sql语句执行情况

>   Mysql优化过程

1.   通过慢日志定位执行较慢的SQL语句
2.   利用explain对这些关键字段进行分析
3.   根据分析结果进行优化

>   MySQL中的日志log

redo log：存储引擎级别的log(InnoDB有，MyISAM没有)，该log关注于事务的恢复，在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性

undo log：是存储引擎级别的log(InnoDB有，MyISAM没有)保证数据的原子性，该log保存了事务发生之前的数据的一个版本，可以用于回滚，是MVCC的重要实现方法之一

bin log：数据库级别的log，关注恢复数据库的数据

>   crash-safe能力是什么

InnoDB通过redo log保证即使数据库发生异常重启，之前提交的记录都不会丢失

>   WAL技术是什么

WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。事务在提交写入磁盘前， 会先写到redo log里面去。如果直接写入磁盘涉及磁盘的随机IO访问，涉及磁盘随机IO访问是非常消耗时间的一个过程，相比之下先写入redo log，后面再找合适的时机批量刷盘能提升性能

>   InnoDB如何保证事务的原子性、持久性和一致性

利用undo log保障原子性。该log保存了事务发生之前的数据的一个版本，可以用于回滚，从而保证事务原子性。 利用redo log保证事务的持久性，该log关注于事务的恢复.在重启mysq服务的时候，根据redo log进行重做，从而使事务有持久性。 利用undo log+redo log保障一致性。事务中的执行需要redo log，如果执行失败，需要undo log 回滚

>   MySQL是如何保证主备一致的

MySQL通过binlog实现主备一致。binlog记录了所有修改了数据库或可能修改数据库的语句，而不会记录select、show这种不会修改数据库的语句。在备份的过程中，主库A会有一个专门的线程将主库A的binlog发送给备库B进行备份。其中binlog有三种记录格式(三种复制类型)：

1.   statement(基于语句)：记录对数据库进行修改的语句本身，有可能会记录一些额外的相关信息。优点是binlog日志量少，IO压力小，性能较高。缺点是由于记录的信息相对较少，在不同库执行时由于上下文的环境不同可能导致主备不一致
2.   row(基于行)：记录对数据库做出修改的语句所影响到的数据行以及对这些行的修改。比如当修改涉及多行数 据，会把涉及的每行数据都记录到binlog。优点是能够完全的还原或者复制日志被记录时的操作。 缺点是日志量占用空间较大，IO压力大，性能消耗较大
3.   mixed(混合)：混合使用上述两种模式，一般的语句使用statment方式进行保存，如果遇到一些特殊的函数，则使用row模式进行记录。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式， 否则就用statement格式。但是在生产环境中，一般会使用row模式

主从复制流程:

1.   在事务完成之前，主库在binlog上记录这些改变，完成binlog写入过程后，主库通知存储引擎提交事物
2.   从库将主库的binlog复制到对应的中继日志，即开辟一个IO工作线程，IO线程在主库上打开一个普通的连接，然后开始binlog dump process，将这些事件写入中继日志。从主库的binlog中读取事 件，如果已经读到最新了，线程进入睡眠并等待ma主库产生新的事件。

>    Mysql复制原理及流程

Mysql内建的复制功能是构建大型、高性能应用程序的基础。将Mysql 的数据分布到多个系统上去，这种分布的机制，是通过将Mysql 的某一台主机的数据复制到其它主机 （slaves）上，并重新执行一遍来实现的

复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。过程如下 1. 主服务器 把更新记录到二进制日志文件中。2.从服务器把主服务器的二进制日志拷贝到自己的中继日志 (replay log)中。3.从服务器重做中继日志中的时间， 把更新应用到自己的数据库上。

>   读写分离

只在MySQL主库上写，只在MySQL从库上读，以減少数据库压力，提高性能

>   redo log与binlog的区别

1.   redo log是InnoDB引擎特有的，只记录该引擎中表的修改记录。binlog是MySQL的Server层实现 的，会记录所有引擎对数据库的修改
2.   redo log是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑
3.   redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

>   两阶段提交是什么

为了保证binlog和redo log两份日志的逻辑一致，最终保证恢复到主备数据库的数据是一致的，采用两阶段提交的机制。

1.   执行器调用存储引擎接口，存储引擎将修改更新到内存中后，将修改操作记录redo log中，此时 redo log处于prepare状态
2.   存储引擎告知执行器执行完毕，执行器生成这个操作对应的binlog，并把binlog写入磁盘。 3. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交commit状态，更新完成

>   只靠binlog可以支持数据库崩溃恢复吗

不可以。 历史原因： 

1.   InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那引入InnoDB原有的 redo log来保证崩溃恢复能力。 实现原因： 
2.   binlog没有记录数据页修改的详细信息，不具备恢复数据页的能力。binlog记录着数据行的增删改， 但是不记录事务对数据页的改动，这样细致的改动只记录在redo log中。当一个事务做增删改时， 其实涉及到的数据页改动非常细致和复杂，包括行的字段改动以及行头部以及数据页头部的改动， 甚至b+tree会因为插入一行而发生若干次页面分裂，那么事务也会把所有这些改动记录下来到redo log中。因为数据库系统进程crash时刻，磁盘上面页面镜像可以非常混乱，其中有些页面含有一些 正在运行着的事务的改动，而一些已提交的事务的改动并没有刷上磁盘。事务恢复过程可以理解为是要把没有提交的事务的页面改动都去掉，并把已经提交的事务的页面改动都加上去这样一个过程。这些信息，都是binlog中没有记录的，只记录在了存储引擎的redo log中
3.   操作写入binlog可细分为write和fsync两个过程，write指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，fsync才是将数据持久化到磁盘的操作。通过参数设置 Sync binlog为0的时候，表示每次提交事务都只write，不fsync。此时数据库崩溃可能导致部分提交 的事务以及binlog日志由于没有持久化而丢失

>   Mysql怎么恢复半个月前的数据

通过整库备份+binlog进行恢复，前提是要有定期整库备份且保存了binlog日志

# 事务

>   事务

事务(transaction)是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消

-   原子性 Atomicity： 一个事务中的所有操作要么全部完成，要么全部不完成
-    一致性 Consistency： 事务执行前后完整性约束没被破坏
-   隔离性  Isolation： 多个并发事务对数据库进行操作，事务间互不干扰
-   持久性 Durability：事务执行完毕，对数据的修改是永久的，即使系统故障也不会丢失

>   事务隔离级别

-   读到未提交数据。脏读
-   读提交。不可重复读
-   可重复读：一个事务执行过程中看到的数据总是和事务启动时看到的数据是一致的。在这个级别下事务未提交，做出的变更其它事务也看不到。幻读(MVCC解决不可重复读，加上间隙锁解决幻读)
-   串行化：对于同一行记录进行读写会分别加读写锁，当发生读写锁冲突，后面执行的事务需等前面执行 的事务完成才能继续执行

>   数据库中多个事务同时进行可能会出现什么问题

-   丟失修改
-   脏读：当前事务可以查看到别的事务未提交的数据
-   不可重读：在同一事务中，使用相同的查询语句，同一数据资源莫名改变了
-   幻读：在同一事务中，使用相同的查询语句，莫名多出了一些之前不存在的数据，或莫名少了一些原先存在的数据

>   MySQL 支持事务吗

在缺省模式下，MySQL是autocommit 模式的。 但是如果你的 MySQL 表类型是使用InnoDB Tables 或BDB tables 的话，你的MySQL 就可以使用事务处理，使用 SET AUTOCOMMIT=0，你必须使用COMMIT 来提交你的更改，或者用ROLLBACK 来回滚你的更改

>   MVCC

MVCC为多版本并发控制，即同一条记录在系统中存在多个版本。其存在目的是在保证数据一致性的前提下提供一种高并发的访问性能。对数据读写在不加读写锁的情况下实现互不干扰，从而实现数据库的隔离性，在事务隔离级别为读提交和可重复读中使用到。 在InnoDB中，事务在开始前会向事务系统申请一个事务ID，该ID是按申请顺序严格递增的。每行数据具有多个版本，每次事务更新数据都会生成新的数据版本，而不会直接覆盖旧的数据版本。数据的行结构中包含多个信息字段。其中实现MVCC的主要涉及最近更改该行数据的事务ID(DB_TRX_ID)和可以找到历史数据版本的指针(DB_ROLL_PTR)。InnoDB在每个事务开启瞬间会为其构造一个记录当前已经开启但未提交的事务ID的视图数组。通过比较链表中的事务ID与该行数据的值与对应的 DB_TRX_ID，并通过DB_ROLL_PTR找到历史数据的值以及对应的DB_TRX_ID来决定当前版本的数据是否应该被当前事务所见。最终实现在不加锁的情况下保证数据的一致性

>   读提交和可重复读都基于MVCC实现，有什么区别

在可重复读级别下，只会在事务开始前创建视图，事务中后续的查询共用一个视图。而读提交级别下每 个语句执行前都会创建新的视图。因此对于可重复读，查询只能看到事务创建前就已经提交的数据。而 对于读提交，查询能看到每个语句启动前已经提交的数据

>   MySQL_fetch_array 和MySQL_fetch_object 的区别是什么

MySQL_fetch_array将结果行作为关联数组或来自数据库的常规数组返回，MySQL_fetch_object从数据库返回结果行作为对象

>   TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上的作用

创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间

>   如果一个表有一列定义为TIMESTAMP，将发生什么

每当行被更改时，时间戳字段将获取当前时间戳

>   如何在 Unix 和Mysql 时间戳之间进行转换

UNIX_TIMESTAMP 是从 Mysql 时间戳转换为Unix 时间戳的命令 
FROM_UNIXTIME 是从 Unix 时间戳转换为Mysql 时间戳的命令

>   主键和候选键的区别（还有外键、超键）

表格的每一行都由主键唯一标识，一个表只有一个主键
主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用

>   Mysql表中有几个触发器

6个。before/after  insert/update/delete

>   字符串函数

insert(s1, index, length, s2) 替换函数，index从1开始

left(str, length)  right(str, length)

>   日期函数

-   curdate ()、current_date() 获取当前日期
-   curtime()、current_time() 获取当前日期
-   now() 获取当前日期和时间
-   datediff(d1, d2) d1 和 d2 之间的天数差
-   adddate(date,  num) 返回 date 日期开始，之后 num 天的日期
-   subdate(date, num) 返回 date 日期开始，之前 num 天的日期

>   存储时期

DateTime YYYY-MM-DD HH:MM:SS占用8个字节

Timestamp 占用四个字节，时间范围小，显示依赖于所指定的时区

>   大数据量分页查询

配合当前页最后一个id进行查询(id必须有序) 
select * from t where id > #{id} limit #{limit}

>   订单表数据量越来越大导致查询缓慢，如何处理

**分库分表**。由于历史订单使用率并不高，高频的可能只是近期订单，因此，将订单表按照时间进行拆分，根据数据量的大小考虑按月分表或按年分表。订单ID最好包含时间(如根据雪花算法生成)，此时既能根据订单ID直接获取到订单记录，也能按照时间进行查询

>   表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，将该字段拆成子表好处是什么

MYSQL数据库的记录存储是按行存储的，数据块大小又是固定的(16K)，每条记录越小，相同的块存储的记录就越多。此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需要查询大字段，进行关联查询。拆分开后， 对字段的 UPDAE 就要UPDATE多个表

>   数据库优化

1.   用 PreparedStatement，一般来说比 Statement 性能高：一个 sql 发给服务器去执行，涉及步骤：语法检查、语义分析，编译，缓存
2.   有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性， 那在设计数据库时就去掉外键
3.   表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等
4.   UNION ALL 要比 UNION 快很多，所以，如果可以确认合并的两个结 果集中不包含重复数据且不需要排序时的话，那么就使用 UNION ALL。UNION 和 UNION ALL 关键字都是将两个结果集合并一个，但这两者从使用和效率上来说都有所不同。1.对重复结果的处理：UNION 在进行表链接后会筛选掉重复的记录，Union All 不会去除重复记录。2. 对排序的处理：Union 将会按照字段的顺序进行排 序；UNION ALL 只是简单的将两个结果合并后就返回
5.   选取最适用的字段属性，尽可能減少定义字段宽度，尽量把字段设置 NOTNULL，例如’省份、‘性 别 最好适用 ENUM
6.   使用连接(JOIN)来代替子查询
7.   适用联合(UNION)来代替手动创建的临时表
8.   事务处理
9.   锁定表、优化事务处理
10.   适用外键，优化锁定表
11.   建立索引

>   Mysql中控制内存分配的全局参数

-   Keybuffersize 指定索引缓冲区大小
-   Innodbbufferpool_size 指定缓冲池字节大小
-   querycachesize
-   readbuffersize 读入缓冲区大小

>   SELECT * 和 SELECT 全部字段 的2种写法有何优缺点

1.   前者要解析数据字典，后者不需要
2.   结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序
3.   表字段改名，前者不需要修改，后者需要改
4.   后者可以建立索引进行优化，前者无法优化
5.   后者的可读性比前者要高

>   HAVNG 子句 和 WHERE 的异同点

1.   语法上：where 用表中列名，having 用select 结果别名
2.   影响结果范围：where从表读出数据的行数，having返回客户端的行数
3.   索引：where可以使用索引，having不能使用索引，只能在临时结果集操作
4.   where后面不能使用聚集函数，having是专门使用聚集函数的

>   SQL注入

SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST和 GET 提交一些sql语句正常执行

防止SQL注入的方式： 

开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime 设置 

执行sql语句时使用 addslashes进行 sql语句转换Sql语句书写尽量不要省略双引号和单引号

过滤掉sql语句中的一些关键词：update、insert、delete、select、*

提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的

>   解释 MySQL 外连接、内连接与自连接的区别

先说什么是交叉连接：交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录—一匹配

内连接则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行

外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。左外连接，也称左连接， 左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要 显示，右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记 录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接

>   完整性约束

-   实体完整性：规定表的每一行在表中是惟一的实体
-   域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定
-   参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性， 防止了数据丢失或无意义的数据在数据库中扩散
-   用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语 义要求。 与表有关的约束：包括列约束(NOT NULL(非空约束))和表约束(PRIMARY KEY、foreign key、check、UNIQUE)

>   MySQL 数据库作发布系统的存储，一天五万条以上的增量，预计运维三年，怎么优化

1.   设计良好的数据库结构，允许部分数据冗余，尽量避免join 查询，提高效率
2.   选择合适的表字段数据类型和存储引擎，适当的添加索引
3.   MySQL 库主从读写分离
4.   找规律分表，减少单表中的数据量提高查询速度
5.   添加缓存机制，比如 memcached、apc等
6.   不经常改动的页面，生成静态页面
7.   书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_ 2, field_ 3 FROM TABLE
