# 代码随想录

## 1、数组 done

>   二分查找法 LeetCode no.704

~~~java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
~~~

>   移除元素 LeetCode：27

```java
public int removeElement(int[] nums, int val) {
    int slow = 0;
    for(int fast = 0; fast < nums.length; fast++) {
        if (nums[fast] != val) {
            nums[slow++] = nums[fast];
        }
    }
    return slow;
}
```

>   有序数组的平方 LeetCode：977

```java
public int[] sortedSquares(int[] nums) {
    int[] result = new int [nums.length];
    int index = nums.length-1;
    int left = 0;
    int right = nums.length - 1;
    while(left <= right) {
        if(Math.abs(nums[left]) > Math.abs(nums[right])) {
            result[index--] = nums[left]*nums[left];
            left++;
        } else {
            result[index--] = nums[right]*nums[right];
            right--;
        }
    }
    return result;
}
```

>   长度最小的子数组 LeetCode 209

```java
public int minSubArrayLen(int target, int[] nums) {
    int left = 0, right = 0, sum = 0, min = Integer.MAX_VALUE;
    for(; right < nums.length; right++) {
        sum += nums[right];
        while (sum >= target) {
            min = Math.min(min, right - left + 1);
            sum -= nums[left];
            left ++;
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
```

>螺旋矩阵II LeetCode：59

```java
public static int[][] generateMatrix(int n) {
    int startx = 0;
    int starty = 0;
    int count = n/2;
    int[][] matrix = new int[n][n];
    int num = 1;
    while(count > 0) {
        for(int i = startx; i < n-startx-1; i++) {
            matrix[starty][i] = num++;
        }

        for (int i = starty; i < n-starty-1; i++) {
            matrix[i][n-startx-1] = num++;
        }

        for (int i = n-startx-1; i > startx; i--) {
            matrix[n-starty-1][i] = num++;
        }

        for (int i = n- starty-1; i>starty; i--) {
            matrix[i][startx] = num++;
        }
        startx ++;
        starty ++;
        count --;
    }

    if (n%2 != 0) {
        matrix[n/2][n/2] = num;
    }
    return matrix;
}
```

## 2、链表 done

>   移除链表元素 LeetCode：203

~~~java
public ListNode removeElements(ListNode head, int val) {
    ListNode pre = new ListNode(-1);
    pre.next = head;
    ListNode cur = pre;
    while (cur.next != null) {
        if (cur.next.val == val) {
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return pre.next;
}
~~~

>   反转链表 LeetCode：206

~~~java
public ListNode reverseList(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode pre = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
~~~

>   两两交换链表中的节点 LeetCode：24

~~~java
public ListNode swapPairs(ListNode head) {
    ListNode node = new ListNode();
    node.next = head;
    ListNode pre = node;
    while (pre.next != null && pre.next.next != null) {
        ListNode first = pre.next;
        ListNode second = pre.next.next;
        pre.next = second;
        first.next = second.next;
        second.next = first;
        pre = pre.next.next;
    }
    return node.next;
}
~~~

>   删除链表倒数第N个节点 LeetCode：19

~~~java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode newHead = new ListNode();
    newHead.next = head;
    ListNode pre = newHead;
    ListNode next = newHead;
    while (n > 0){
        next = next.next;
        if (next == null) {
            return head;
        }
        n--;
    }
    while (next.next != null) {
        pre = pre.next;
        next = next.next;
    }
    pre.next = pre.next.next;
    return newHead.next;
}
~~~

>   环形链表II LeetCode：142

~~~java
public ListNode detectCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            ListNode node1 = head;
            ListNode node2 = slow;
            while (node1 != node2) {
                node1 = node1.next;
                node2 = node2.next;
            }
            return node1;
        }
    }
    return null;
}
~~~



## 3、哈希 done

>   有效的字母异位词 LeetCode no.242

~~~java
public boolean isAnagram(String s, String t) {
    HashMap<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
    }
    for (int i = 0; i < t.length(); i++) {
        map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) - 1);
        if (map.get(t.charAt(i)) < 0) {
            return false;
        }
    }
    for (Integer val : map.values()) {
        if (val > 0) {
            return false;
        }
    }
    return true;
}
~~~

>   两个数组的交集 LeetCode no.349

~~~java
public int[] intersection(int[] nums1, int[] nums2) {
    HashSet<Integer> set = new HashSet<>();
    HashSet<Integer> result = new HashSet<>();
    for (int i = 0; i < nums1.length; i++) {
        set.add(nums1[i]);
    }
    for (int i = 0; i < nums2.length; i++) {
        if (set.contains(nums2[i])) {
            result.add(nums2[i]);
        }
    }
    return result.stream().mapToInt(i -> i).toArray();
}
~~~

>   两数之和 LeetCode no.1

~~~java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(target - nums[i])) {
            return new int[]{map.get(target - nums[i]), i};
        } else {
            map.put(nums[i], i);
        }
    }
    return null;
}
~~~

>   四数相加(不需要去重) LeetCode no.454

~~~java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    HashMap<Integer, Integer> map1 = new HashMap<>();
    HashMap<Integer, Integer> map2 = new HashMap<>();
    for (int i = 0; i < nums1.length; i++) {
        for (int j = 0; j < nums2.length; j++) {
            map1.put(nums1[i] + nums2[j], map1.getOrDefault(nums1[i] + nums2[j], 0) + 1);
        }
    }
    for (int i = 0; i < nums3.length; i++) {
        for (int j = 0; j < nums4.length; j++) {
            map2.put(nums3[i] + nums4[j], map2.getOrDefault(nums3[i] + nums4[j], 0) + 1);
        }
    }
    int sum = 0;
    for (int num : map1.keySet()) {
        if (map2.containsKey(0 - num)) {
            sum += map1.get(num) * map2.get(0 - num);
        }
    }
    return sum;
}
~~~

>   三数之和(需要去重)LeetCode no.15

~~~java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums);
    int left;
    int right;
    for (int i = 0; i < nums.length - 2; i++) {
        if (nums[i] > 0) {
            break;
        }
        if (i>0 && nums[i] == nums[i-1]) {
            continue;
        }
        left = i + 1;
        right = nums.length - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                result.add(Arrays.asList(nums[i], nums[left++], nums[right--]));
                while (left < right && nums[left] == nums[left-1]) {
                    left++;
                }
                while (left < right && nums[right] == nums[right+1]) {
                    right--;
                }
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
~~~

>   四数之和(去重) LeetCode no.18

~~~java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums);
    int left;
    int right;
    for (int k = 0; k < nums.length - 3; k++) {
        if (k >= 1 && nums[k] == nums[k-1]) {
            continue;
        }
        for (int i = k + 1; i < nums.length - 2; i++) {
            int targetk = target - nums[k];
            if (nums[i] > 0 && nums[i] >=targetk) {
                break;
            }
            if (i > k+1 && nums[i] == nums[i-1]) {
                continue;
            }
            left = i + 1;
            right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == targetk) {
                    result.add(Arrays.asList(nums[k], nums[i], nums[left++], nums[right--]));
                    while (left < right && nums[left] == nums[left-1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right+1]) {
                        right--;
                    }
                } else if (sum < targetk) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }
    return result;
}
~~~





## 4、字符串 done

>   反转字符串 LeetCode no.344

~~~java
public void reverseString(char[] s) {
    int start = 0, end = s.length - 1;
    while (start < end) {
        char temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end--;
    }
}
~~~

>   反转字符串II LeetCode no.541

~~~java
public void reverseString(char[] s, int x, int y) {
    int start = x, end = y;
    while (start < end) {
        char temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end--;
    }
}

public String reverseStr(String s, int k) {
    int start = 0;
    char[] ch = s.toCharArray();
    while (start < s.length()) {
        if (start + k < s.length()) {
            reverseString(ch, start, start + k - 1);
        } else {
            reverseString(ch, start, s.length() - 1);
        }
        start = start + 2*k;
    }
    return new String(ch);
}
~~~

>   反转字符串里的单词 LeetCode no.151

~~~java
// 先反转整个字符串，再反转单个单词
public String reverseWords(String s) {
    StringBuffer sb = eraseString(s);
    reverseString(sb, 0, sb.length() - 1);
    reverseWord(sb);
    return sb.toString();
}

public void reverseString(StringBuffer sb, int start, int end) {
    int begin = start, last = end;
    while (begin < last) {
        char temp = sb.charAt(begin);
        sb.setCharAt(begin, sb.charAt(last));
        sb.setCharAt(last, temp);
        begin ++;
        last --;
    }
}

public void reverseWord(StringBuffer sb) {
    int start = 0, end = 1;
    while(end < sb.length()) {
        while (end < sb.length() && sb.charAt(end) != ' ') {
            end ++;
        }
        reverseString(sb, start, end - 1);
        start = end + 1;
        end = start + 1;
    }
}

public StringBuffer eraseString(String s) {
    int start = 0;
    int end = s.length() - 1;
    while (s.charAt(start) == ' ') {
        start ++;
    }
    while (s.charAt(end) == ' ') {
        end --;
    }
    StringBuffer sb = new StringBuffer();
    while (start <= end) {
        if (s.charAt(start) != ' ' || sb.charAt(sb.length()-1) != ' ') {
            sb.append(s.charAt(start));
        }
        start ++;
    }
    return sb;
}
~~~

>   KMP LeetCode 28

~~~java
public int strStr(String haystack, String needle) {
    if (needle == null || needle.length() == 0) {
        return 0;
    }
    int len = needle.length();
    int[] next = new int[len];
    getNext(next, needle);
    int j = -1;
    for (int i = 0; i < haystack.length(); i++) {
        while (j >= 0 && haystack.charAt(i) != needle.charAt(j + 1)) {
            j = next[j];
        }
        if (haystack.charAt(i) == needle.charAt(j + 1)) {
            j++;
        }
        if (j == len - 1) {
            return i - len + 1;
        }
    }
    return -1;
}

public void getNext(int[] next, String s) {
    int j = -1;
    next[0] = j;
    for (int i = 1; i < s.length(); i++) {
        while (j >= 0 && s.charAt(i) != s.charAt(j + 1)) {
            j = next[j];
        }
        if (s.charAt(i) == s.charAt(j + 1)) {
            j++;
        }
        next[i] = j;
    }
}
~~~

>重复的子字符串 LeetCode：459

~~~java
public boolean repeatedSubstringPattern(String s) {
    String str = s + s;
    return str.substring(1, str.length() - 1).contains(s);
}
~~~





## 5、栈与队列 done

>   用栈实现队列 LeetCode no.232

~~~java
class MyQueue {
    Stack<Integer> stackIn = new Stack<>();
    Stack<Integer> stackOut = new Stack<>();
    public MyQueue() {
    }
    
    public void push(int x) {
        stackIn.push(x);
    }
    
    public int pop() {
        InToOut();
        return stackOut.pop();
    }
    
    public int peek() {
        InToOut();
        return stackOut.peek();
    }
    
    public boolean empty() {
        return stackIn.isEmpty() && stackOut.isEmpty();
    }

    public void InToOut() {
        if (stackOut.isEmpty()) {
            while (!stackIn.isEmpty()) {
                stackOut.push(stackIn.pop());
            }
        }
    }
}
~~~

>   用队列实现栈 LeetCode: 225

~~~java
class MyStack {

    Queue<Integer> queueIn = new LinkedList<>();
    Queue<Integer> queueOut = new LinkedList<>();
    public MyStack() {
    }
    
    public void push(int x) {
        Queue<Integer> queuetmp;
        queuetmp = queueIn;
        queueIn = queueOut;
        queueOut = queuetmp;
        queueIn.add(x);
        while(!queueOut.isEmpty()) {
            queueIn.add(queueOut.poll());
        }
    }
    
    public int pop() {
        return queueIn.poll();
    }
    
    public int top() {
        return queueIn.peek();
    }
    
    public boolean empty() {
        return queueIn.isEmpty();
    }

    public void inToOut() {
        if (!queueOut.isEmpty()) {

        }
    }
}
~~~

>   有效的括号 LeetCode no.20

~~~java
public boolean isValid(String s) {
    if (s.length() == 1) {
        return false;
    }

    Stack<Character> stack = new Stack<>();
    char[] chars = s.toCharArray();
    for (int i = 0; i < chars.length; i++) {
        if (isLeft(chars[i])) {
            stack.push(chars[i]);
        } else {
            if (stack.isEmpty() || stack.pop() != findAnother(chars[i])) {
                return false;
            }
        }
    }
    if (stack.isEmpty()) {
        return true;
    } else {
        return false;
    }
}

public boolean isLeft(char c) {
    if (c == '(' || c == '{' || c == '[') {
        return true;
    } else {
        return false;
    }
}

public char findAnother(char c) {
    if (c == ')') {
        return '(';
    } else if (c == '}') {
        return '{';
    } else {
        return '[';
    }
}
~~~

>   删除字符串中的所有相邻重复项 LeetCode no.1047

~~~java
public String removeDuplicates(String s) {
    char[] chs = s.toCharArray();
    Stack<Character> stack = new Stack<>();
    for (int i = 0; i < chs.length; i++) {
        if (!stack.isEmpty() && stack.peek() == chs[i]) {
            stack.pop();
        } else {
            stack.push(chs[i]);
        }
    }
    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) {
        sb.append(stack.pop());
    }
    return sb.reverse().toString();
}
~~~

>   逆波兰表达式求值 LeetCode：150

~~~java
public int evalRPN(String[] tokens) {
    Stack<Integer> stack = new Stack<>();
    for (String token : tokens) {
        if (token.equals("+")) {
            int s1 = stack.pop();
            int s2 = stack.pop();
            stack.push(s1 + s2);
        } else if (token.equals("-")) {
            int s1 = stack.pop();
            int s2 = stack.pop();
            stack.push(s2 - s1);
        } else if (token.equals("*")) {
            int s1 = stack.pop();
            int s2 = stack.pop();
            stack.push(s1 * s2);
        } else if (token.equals("/")) {
            int s1 = stack.pop();
            int s2 = stack.pop();
            stack.push(s2 / s1);
        } else {
            stack.push(Integer.parseInt(token));
        }
    }
    return stack.pop();
}
~~~

>   滑动窗口最大值 LeetCode：239

~~~java
public class MyQueue {
    Deque<Integer> deque = new LinkedList<>();
    public int peak() {
        return deque.peek();
    }

    public void poll(int val) {
        if (deque.size() != 0 && val == deque.peek()) {
            deque.poll();
        }
    }

    public void push(int val) {
        while (!deque.isEmpty() && val > deque.getLast()) {
            deque.removeLast();
        }
        deque.addLast(val);
    }
}

public int[] maxSlidingWindow(int[] nums, int k) {
    if (nums.length == 1) {
        return nums;
    }
    MyQueue queue = new MyQueue();
    for (int i = 0; i < k; i++) {
        queue.push(nums[i]);
    }
    int[] res = new int[nums.length - k + 1];
    int num = 0;
    res[num++] = queue.peak();
    for (int i = k; i < nums.length; i++) {
        queue.poll(nums[i - k]);
        queue.push(nums[i]);
        res[num++] = queue.peak();
    }
    return res;
}
~~~

>   前 K 个高频元素 LeetCode：347

~~~java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
    }
    PriorityQueue<int[]> pq = new PriorityQueue<>((pair1, pair2) -> pair1[1] - pair2[1]);
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        int[] mem = new int[2];
        mem[0] = entry.getKey();
        mem[1] = entry.getValue();
        pq.offer(mem);
        if (pq.size() > k) {
            pq.poll();
        }
    }
    int[] res = new int[k];
    for (int i = 0; i < k; i++) {
        res[i] = pq.poll()[0];
    }
    return res;
}
~~~

## 6、二叉树 done

>   递归遍历 前序遍历(中、左、右) LeetCode no.144 

~~~java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    result.add(root.val);
    result.addAll(preorderTraversal(root.left));
    result.addAll(preorderTraversal(root.right));
    return result;
}
~~~

>   递归遍历 后序遍历(左、右、中) LeetCode no.145

~~~java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    result.addAll(postorderTraversal(root.left));
    result.addAll(postorderTraversal(root.right));
    result.add(root.val);
    return result;
}
~~~

>   递归遍历 中序遍历(左、中、右) LeetCode no.94

~~~java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    result.addAll(inorderTraversal(root.left));
    result.add(root.val);
    result.addAll(inorderTraversal(root.right));
    return result;
}
~~~

>   非递归遍历 (使用一个栈)

>   层序遍历 LeetCode no.102

~~~java
public List<List<Integer>> levelOrder(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }
    List<List<Integer>> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int curNum = 0;
    while (queue.size() > 0) {
        curNum = queue.size();
        List<Integer> curList = new ArrayList<>();
        while (curNum > 0) {
            TreeNode node = queue.poll();
            curNum--;
            curList.add(node.val);
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        result.add(curList);
    }
    return result;
}
~~~

>   翻转二叉树 LeetCode no.226

~~~java
public TreeNode invertTree(TreeNode root) {
    swapTreeNode(root);
    return root;
}

public void swapTreeNode(TreeNode root) {
    if (root == null) {
        return;
    }
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    swapTreeNode(root.left);
    swapTreeNode(root.right);
}
~~~

>   对称二叉树 LeetCode no.101

~~~java
public boolean isSymmetric(TreeNode root) {
    return compare(root.left, root.right);
}

public boolean compare(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }
    if (left != null && right != null) {
        return left.val == right.val && compare(left.left, right.right)
            && compare(left.right, right.left);
    }
    return false;
}
~~~

>   二叉树的最大深度 LeetCode no.104

~~~java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
~~~

>   二叉树的最小深度 LeetCode no.111

~~~java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null && root.right == null) {
        return 1;
    }
    if (root.left == null) {
        return minDepth(root.right) + 1;
    }
    if (root.right == null) {
        return minDepth(root.left) + 1;
    }
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}
~~~

>   完全二叉树节点的数量 LeetCode no.222

~~~java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = 0;
    int rightDepth = 0;
    TreeNode left = root.left;
    TreeNode right = root.right;
    while (left != null) {
        leftDepth++;
        left = left.left;
    }
    while (right != null) {
        rightDepth++;
        right = right.right;
    }
    if (leftDepth == rightDepth) {
        double v = (Math.pow(2, leftDepth + 1)) - 1;
        return (int) v;
    }
    return countNodes(root.left) + countNodes(root.right) + 1;
}
~~~

>   判断是否是平衡二叉树 LeetCode no.110

~~~java
public boolean isBalanced(TreeNode root) {
    if (getHeight(root) != -1) {
        return true;
    }
    return false;
}

public int getHeight(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = getHeight(root.left);
    int rightHeight = getHeight(root.right);
    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {
        return -1;
    }
    return 1 + Math.max(getHeight(root.left), getHeight(root.right));
}
~~~

>   二叉树的所有路径 LeetCode no.257

~~~java
List<String> res = new ArrayList<>();

public List<String> binaryTreePaths(TreeNode root) {
    if (root == null) {
        return null;
    }
    traverse(root, "");
    return res;
}

public void traverse(TreeNode root, String path) {
    if (root == null) {
        return;
    }
    if (root.left == null && root.right == null) {
        res.add(new StringBuilder(path).append(root.val).toString());
        return;
    }
    String tmp = new StringBuilder(path).append(root.val).append("->").toString();
    traverse(root.left, tmp);
    traverse(root.right, tmp);
}
~~~

>   左叶子之和 LeetCode no.404

~~~java
int sum = 0;
public int sumOfLeftLeaves(TreeNode root) {
    travelLeft(root);
    return sum;
}

public void travelLeft(TreeNode root) {
    if (root == null) {
        return;
    }
    travelLeft(root.right);
    if (root.left != null && root.left.left == null && root.left.right == null) {
        sum += root.left.val;
        return;
    }
    travelLeft(root.left);
}
~~~

>   树左下角的值 LeetCode no.513

~~~java
int maxDepth = 1;
int maxLeftValue = 0;
public int findBottomLeftValue(TreeNode root) {
    maxLeftValue = root.val;
    int curDepth = 1;
    findLeft(root, curDepth);
    return maxLeftValue;
}

public void findLeft(TreeNode root, int curDepth) {
    if (root.left == null && root.right == null && curDepth > maxDepth) {
        maxDepth = curDepth;
        maxLeftValue = root.val;
        return;
    }
    if (root.left != null) {
        findLeft(root.left, curDepth + 1);
    }
    if (root.right != null) {
        findLeft(root.right, curDepth + 1);
    }
}
~~~

>   路径总和 LeetCode no.112

~~~java
public boolean hasPathSum(TreeNode root, int targetSum) {
    return travelValues(root, targetSum);
}

public boolean travelValues(TreeNode root, int targetSum) {
    if (root == null) {
        return false;
    }
    if (root.left != null || root.right != null) {
        return travelValues(root.left, targetSum - root.val)
            || travelValues(root.right, targetSum - root.val);
    }
    return root.val == targetSum;
}
~~~

>   从中序与后序遍历序列构造二叉树 LeetCode no.106

~~~java
HashMap<Integer, Integer> locationMap;
public TreeNode buildTree(int[] inorder, int[] postorder) {
    locationMap = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
        locationMap.put(inorder[i], i);
    }
    return findNode(inorder, 0, inorder.length -1, postorder, 0, postorder.length -1);

}
public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {
    if (inBegin > inEnd || postBegin > postEnd) {
        return null;
    }
    int position = locationMap.get(postorder[postEnd]);
    TreeNode root = new TreeNode(inorder[position]);
    int leftLength = position - inBegin;
    root.left = findNode(inorder, inBegin, position - 1 , postorder, postBegin, postBegin + leftLength - 1);
    root.right = findNode(inorder, position + 1, inEnd, postorder, postBegin + leftLength, postEnd - 1);
    return root;
}
~~~

>   最大二叉树 LeetCode no.654
>
>   给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:
>
>   1.  创建一个根节点，其值为 `nums` 中的最大值。
>   2.  递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
>   3.  递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

~~~java
public TreeNode constructMaximumBinaryTree(int[] nums) {
    return buildMaxBinaryTree(nums, 0, nums.length-1);
}

public TreeNode buildMaxBinaryTree(int[] nums, int start, int end) {
    if (start > end) {
        return null;
    }
    int MaxValue = nums[start];
    int split = start;
    for (int i = start + 1; i <= end; i++) {
        if (nums[i] > MaxValue) {
            MaxValue = nums[i];
            split = i;
        }
    }
    TreeNode root = new TreeNode(MaxValue);
    root.left = buildMaxBinaryTree(nums, start, split - 1);
    root.right = buildMaxBinaryTree(nums, split + 1, end);
    return root;
}
~~~

>   合并二叉树 LeetCode no.617

~~~java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) { 
        return root2; 
    }
    if (root2 == null) { 
        return root1; 
    }
    root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    return root1;
}
~~~

>   二叉搜索树中的搜索 LeetCode no.700

~~~java
public TreeNode searchBST(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    if (root.val == val) {
        return root;
    }
    if (root.val > val) {
        return searchBST(root.left, val);
    }
    return searchBST(root.right, val);
}
~~~

>   验证二叉搜索树 LeetCode no.98

~~~java
private long MIN_VALUE = Long.MIN_VALUE;;
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    boolean left = isValidBST(root.left);
    if (root.val > MIN_VALUE) {
        MIN_VALUE = root.val;
    } else {
        return false;
    }
    boolean right = isValidBST(root.right);
    return left && right;
}
~~~

>   二叉搜索树的最小绝对差 LeetCode no.530

~~~java
TreeNode pre = null;
int minResult = Integer.MAX_VALUE;
public int getMinimumDifference(TreeNode root) {
    travel(root);
    return minResult;
}

public void travel(TreeNode root) {
    if (root == null) {
        return;
    }
    travel(root.left);
    if (pre != null) {
        minResult = Math.min(minResult, root.val - pre.val);
    }
    pre = root;
    travel(root.right);
}
~~~

>   二叉搜索树中的众数 LeetCode no.501

~~~java
TreeNode pre = null;
int curMax = 0;
int curNum = 0;
HashSet<Integer> resultSet = new HashSet<>();
TreeNode numPre = null;
public int[] findMode(TreeNode root) {
    findMaxNum(root);
    return resultSet.stream().mapToInt(i -> i).toArray();
}
    public void findMaxNum (TreeNode root) {
    if (root == null) {
        return;
    }
    findMaxNum(root.left);
    if (pre == null || root.val != pre.val) {
        curNum = 1;
    } else {
        curNum ++;
    }
    if (curNum == curMax) {
        resultSet.add(root.val);
    } else if (curNum > curMax) {
        curMax = curNum;
        resultSet.clear();
        resultSet.add(root.val);
    }
    pre = root;
    findMaxNum(root.right);
}
~~~

>   二叉树的最近公共祖先 LeetCode no.236

~~~java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null) {
        return null;
    }
    if (root.val == p.val || root.val == q.val) {
        return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left == null && right == null ) {
        return null;
    }
    if (left != null && right != null) {
        return root;
    }
    if (left == null && right != null) {
        return right;
    }
    return left;
}
~~~

>   二叉搜索树的最近公共祖先 LeetCode no.235

~~~java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root.val > p.val && root.val > q.val) {
        return lowestCommonAncestor(root.left, p, q);
    }
    if (root.val < p.val && root.val < q.val) {
        return lowestCommonAncestor(root.right, p, q);
    }
    return root;
}
~~~

>   二叉搜索树的插入操作 LeetCode no.701

~~~java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }
    if (root.val > val) {
        root.left = insertIntoBST(root.left, val);
    }
    if (root.val < val) {
        root.right = insertIntoBST(root.right, val);
    }
    return root;
}
~~~

>   删除二叉搜索树中的节点 LeetCode no.450

~~~java
public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) {
        return null;
    }
    if (root.val == key) {
        if (root.left == null) {
            return root.right;
        } else if (root.right == null) {
            return root.left;
        } else {
            TreeNode cur = root.right;
            while (cur.left != null) {
                cur = cur.left;
            }
            cur.left = root.left;
            root = root.right;
            return root;
        }
    }
    if (root.val > key) {
        root.left = deleteNode(root.left, key);
    }
    if (root.val < key) {
        root.right = deleteNode(root.right, key);
    }
    return root;
}
~~~

>   修建二叉搜索树 LeetCode no.669

~~~java
public TreeNode trimBST(TreeNode root, int low, int high) {
    if (root == null) {
        return null;
    }
    if (root.val < low ) {
        return trimBST(root.right, low, high);
    }
    if (root.val > high ) {
        return trimBST(root.left, low, high);
    }
    root.left = trimBST(root.left, low, high);
    root.right = trimBST(root.right, low, high);
    return root;
}
~~~

>   将有序数组转化为二叉搜索树(平衡) LeetCode no.108

~~~java
public TreeNode sortedArrayToBST(int[] nums) {
    return buildBST(nums, 0, nums.length - 1);
}

public TreeNode buildBST(int[] nums, int start, int end) {
    if (start > end) {
        return null;
    }
    int mid = (start + end) / 2;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = buildBST(nums, start, mid - 1);
    root.right = buildBST(nums, mid + 1, end);
    return root;
}
~~~

>   将二叉搜索树转化为累加树 LeetCode no.538

~~~java
int sum;
public TreeNode convertBST(TreeNode root) {
    sum = 0;
    fillValue(root);
    return root;
}

public void fillValue(TreeNode root) {
    if (root == null) {
        return ;
    }
    fillValue(root.right);
    root.val += sum;
    sum = root.val;
    fillValue(root.left);
}
~~~



## 7、回溯算法

## 8、贪心算法 ing

>   分发饼干 LeetCode no.455 
>
>   假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
>   对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

~~~java
public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    int i = g.length -1;
    int j = s.length -1;
    int count = 0;
    while (i >= 0 && j >= 0) {
        if (s[j] >= g[i]) {
            j--;
            i--;
            count ++;
        } else {
            i--;
        }
    }
    return count;
}
~~~

>   摆动序列 LeetCode no.376
>
>   如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
>   **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
>   给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

~~~java
public int wiggleMaxLength(int[] nums) {
    if (nums.length == 1) {
        return 1;
    }
    int count = 1;
    int prediff = 0;
    int curdiff = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        curdiff = nums[i+1] - nums[i];
        if (curdiff > 0 && prediff <= 0 || curdiff < 0 && prediff >= 0) {
            count ++;
            prediff = curdiff;
        }
    }
    return count;
}
~~~

>   最大子序和 LeetCode no.53

~~~java
public int maxSubArray(int[] nums) {
    int max = nums[0];
    int cur = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (cur < 0) {
            cur = nums[i];
        } else {
            cur += nums[i];
        }
        if (cur > max) {
            max = cur;
        }
    }
    return max;
}
~~~

>   买卖股票的最佳时机 II   LeetCode no.122
>
>   给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
>
>   在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
>
>   返回 *你能获得的 **最大** 利润* 。

~~~java
public int maxProfit(int[] prices) {
    if (prices.length == 1) {
        return 0;
    }
    int max = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i-1]) {
            max += prices[i] - prices[i-1];
        }
    }
    return max;
}
~~~

>   跳跃游戏 LeetCode no.55
>
>   给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
>   判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

~~~java
public boolean canJump(int[] nums) {
    int coverage = 0;
    for (int i = 0; i <= coverage; i++) {
        coverage = Math.max(coverage, i + nums[i]);
        if (coverage >= nums.length - 1) {
            return true;
        }
    }
    return false;
}
~~~

>   **跳跃游戏II LeetCode 45**
>
>   给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。
>
>   每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度	
>
>   返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

~~~java
public int jump(int[] nums) {
    if (nums.length == 1) {
        return 0;
    }
    int count = 0;
    int curDistance = 0;
    int maxDistance = 0;
    for (int i = 0; i < nums.length; i ++) {
        if (nums[i] + i >= maxDistance) {
            maxDistance = i + nums[i];
        }
        if (i == curDistance) {
            curDistance = maxDistance;
            count ++;
        }
        if (curDistance >= nums.length - 1) {
            return count;
        }
    }
    return 0;
}
~~~

>   K次取反后最大化的数组和  LeetCode no.1005
>
>   给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：
>
>   -   选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。
>
>   重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。
>
>   以这种方式修改数组后，返回数组 **可能的最大和** 

~~~java
public int largestSumAfterKNegations(int[] nums, int k) {
    Arrays.sort(nums);
    int i = 0;
    for (; i < nums.length && k > 0; i++) {
        if (nums[i] < 0) {
            nums[i] = - nums[i];
            k--;         
        }
    }
    int sum = 0;
    for(int j = 0; j < nums.length; j++){
        sum += nums[j];
    }
    if (k == 0 || k % 2 == 0) {
        return sum;
    }
    Arrays.sort(nums);
    return sum - 2 * nums[0];
}
~~~

>   加油站 LeetCode no.134
>
>   在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。
>
>   你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。
>
>   给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

~~~java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int curSum = 0;
    int totalSum = 0;
    int index = 0;
    for (int i = 0; i < gas.length; i++) {
        curSum += gas[i] - cost[i];
        totalSum += gas[i] - cost[i];
        if (curSum < 0) {
            index = (i + 1) % gas.length ; 
            curSum = 0;
        }
    }
    if (totalSum < 0) return -1;
    return index;
}
~~~

>   分发糖果 LeetCode no.135
>
>   `n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。
>
>   你需要按照以下要求，给这些孩子分发糖果：
>
>   -   每个孩子至少分配到 `1` 个糖果。
>   -   相邻两个孩子评分更高的孩子会获得更多的糖果。
>
>   请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

~~~java
public int candy(int[] ratings) {
    int num = ratings.length;
    int[] result = new int[num];
    Arrays.fill(result, 1);
    for (int i = 1; i < num; i++) {
        if (ratings[i] > ratings[i - 1]) {
            result[i] = result[i - 1] + 1;
        }
    }
    for (int i = num - 2 ; i >= 0 ; i--) {
        if (ratings[i] > ratings[i + 1]) {
            result[i] = Math.max(result[i + 1] + 1, result[i]);
        }
    }
    return Arrays.stream(result).sum();
}
~~~

>   柠檬水找零 LeetCode no.860
>
>   在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。
>
>   每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。
>
>   注意，一开始你手头没有任何零钱。
>
>   给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

~~~java
public boolean lemonadeChange(int[] bills) {
    int fiveNum = 0;
    int tenNum = 0;
    for (int bill : bills) {
        if (bill == 5) {
            fiveNum ++;
        } else if (bill == 10) {
            fiveNum --;
            tenNum ++;
        } else {
            if (tenNum > 0) {
                tenNum --;
                fiveNum --;
            } else {
                fiveNum -= 3;
            }
        }
        if (fiveNum < 0) {
            return false;
        }
    }
    return true;
}
~~~

>   **根据身高重建队列 LeetCode no.406**
>
>   假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。
>
>   请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

~~~java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];   
          // a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列
            return b[0] - a[0];   //b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列
        });

        LinkedList<int[]> que = new LinkedList<>();

        for (int[] p : people) {
            que.add(p[1],p);   //Linkedlist.add(index, value)，會將value插入到指定index裡。
        }

        return que.toArray(new int[people.length][]);
    }
  
  // 我的理解 插入时，如果同位置已有，一定是比自己大的，所以不影响他的结果
~~~

>   用最小的弓箭数引爆气球 LeetCode no.452有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。
>
>   一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。
>
>   给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

~~~java
public int findMinArrowShots(int[][] points) {
    // 使用Integer内置比较方法，不会溢出
    Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));
    int count = 1;
    for (int i = 0; i < points.length - 1; i++) {
        if (points[i][1] >= points[i + 1][0]) {
            points[i + 1][1] = Math.min(points[i + 1][1], points[i][1]);
        } else {
            count ++;
        }
    }
    return count;
}
~~~

>   无重叠区间 LeetCode no.435
>
>   给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。
>
>   **注意** 只在一点上接触的区间是 **不重叠的**。例如 `[1, 2]` 和 `[2, 3]` 是不重叠的。

~~~java
public int eraseOverlapIntervals(int[][] intervals) {
    int count = 0;
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
    for (int i = 0; i < intervals.length - 1; i++) {
        if (intervals[i][1] > intervals[i + 1][0]) {
            intervals[i + 1][1] = Math.min(intervals[i + 1][1], intervals[i][1]);
            count ++;
        }
    }
    return count;
}	
~~~

>   划分字母区间 LeetCode no.763
>
>   给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。
>
>   注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。
>
>   返回一个表示每个字符串片段的长度的列表。

~~~java
public List<Integer> partitionLabels(String s) {
    char[] chs = s.toCharArray();
    int[] distance = new int[26];
    for (int i = 0; i < chs.length; i++) {
        distance[chs[i] - 'a'] = i;
    }
    List<Integer> res = new ArrayList<>();
    int last = -1;
    int max = 0;
    for (int i = 0; i < chs.length; i++) {
        max = Math.max(max, distance[chs[i] - 'a']);
        if (max == i) {
            res.add(i - last);
            last = i;
        }
    }
    return res;
}
~~~

>   合并区间 LeetCode：56

~~~java
public int[][] merge(int[][] intervals) {
    Arrays.sort(intervals, new Comparator<int[]>() {
        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0];
        }
    });
    List<int[]> res = new ArrayList<>();
    int curStart = intervals[0][0];
    int curEnd = intervals[0][1];
    int lastEnd = 0;
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] > curEnd) {
            res.add(new int[]{curStart, curEnd});
            lastEnd = curEnd;
            curStart = intervals[i][0];
            curEnd = intervals[i][1];
        } else {
            curEnd = Math.max(curEnd, intervals[i][1]);
        }
    }
    if (curEnd > lastEnd) {
        res.add(new int[]{curStart, curEnd});
    }
    return res.toArray(new int[res.size()][]);
}
~~~

>   单调自增的数字 LeetCode:738

~~~java
public int monotoneIncreasingDigits(int n) {
    char[] ch = Integer.toString(n).toCharArray();
    int start = ch.length;
    for (int i = ch.length - 2; i >= 0; i --) {
        if (ch[i] > ch[i + 1]) {
            ch[i] -= 1;
            start = i + 1;
        }
    }
    for (int j = start; j < ch.length; j++) {
        ch[j] = '9';
    }
    return Integer.parseInt(new String(ch));
}
~~~

>   监督二叉树 LeetCode:968

~~~java
int result = 0;
public int minCameraCover(TreeNode root) {
    // 0 无监督 1 有覆盖 2 有摄像头
    if (travel(root) == 0) {
        result ++;
    }
    return result;
}

public int travel(TreeNode root) {
    if (root.left == null && root.right == null) {
        return 0;
    }
    int left = 1, right = 1;
    if (root.left != null) {
        left = travel(root.left);
    }
    if (root.right != null) {
        right = travel(root.right);
    }
    if (left == 0 || right == 0) {
        result ++;
        return 2;
    }
    if (left == 2 || right == 2) {
        return 1;
    } else {
        return 0;
    }
}
~~~



## 9、动态规划 ing

>   斐波那契数列 LeetCode no.509

~~~java
public int fib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
~~~

>   爬楼梯 LeetCode no.70

~~~java
public int climbStairs(int n) {
    if (n == 1 || n == 0) {
        return 1;
    }
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
~~~

>   花最小代价爬楼梯 LeetCode no.746

~~~java
public int minCostClimbingStairs(int[] cost) {
    int[] dp = new int[cost.length + 1];
    dp [0] = 0;
    dp [1] = 0;
    for (int i = 2; i <= cost.length ; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2]+ cost[i - 2]);
    }
    return dp[cost.length];
}
~~~

>   不同路径 LeetCode no.62

~~~java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int i = 1; i < n; i++) {
        dp[0][i] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
~~~

>   不同路径II(多了障碍) LeetCode no.63

~~~java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) {
        if (obstacleGrid[i][0] == 1) {
            break;
        }
        dp[i][0] = 1;
    }
    for (int i = 0; i < n; i++) {
        if (obstacleGrid[0][i] == 1) {
            break;
        }
        dp[0][i] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (obstacleGrid[i][j] == 1) {
                dp[i][j] = 0;
            } else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
    }
    return dp[m - 1][n - 1];
}
~~~

>   整数拆分 LeetCode no.343

~~~java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[2] = 1;
    for (int i = 3; i <= n; i++) {
        for (int j = 1; j <= i-j; j++) {
            // 相当于固定好j，不必对j进行拆分，因为1*dp[i-1]肯定覆盖了
            dp[i] = Math.max(dp[i], Math.max(dp[i - j] * j, j*(i-j)));
        }
    }
    return dp[n];
}
~~~

>   不同的二叉搜索树 LeetCode no.96

~~~java
public int numTrees(int n) {
    if (n == 1) {
        return 1;
    }
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - j - 1];
        }
    }
    return dp[n];
}
~~~

>   分割等和子集 LeetCode no.416

~~~java
public boolean canPartition(int[] nums) {
    int sum = Arrays.stream(nums).sum();
    if (sum % 2 == 1) {
        return false;
    }
    int target = sum / 2;
    int[] dp = new int[target + 1];
    dp[0] = 0;
    for (int i = 0; i < nums.length; i++) {
        for (int j = target; j >= nums[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            if (dp[j] == target) {
                return true;
            }
        }
    }
    return false;
}
~~~

>   最后一块石头的重量II LeetCode：1049 岩石相互粉碎，最后一块石头重量

~~~java
public int lastStoneWeightII(int[] stones) {
    int sum = Arrays.stream(stones).sum();
    int target = sum / 2;
    int[] dp = new int[target + 1];
    for (int i = 0; i < stones.length; i++) {
        for (int j = target; j >= stones[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
        }
    }
    return sum - 2 * dp[target];
}
~~~

>   目标和 LeetCode：494 数组中的数字可以相加或者相减，多少种组合

~~~java
public int findTargetSumWays(int[] nums, int target) {
    int sum = Arrays.stream(nums).sum();
    if (Math.abs(target) > sum || (sum + target) % 2 != 0) {
        return 0;
    }
    int addSum = (sum + target) / 2 ;
    int[] dp = new int[addSum + 1];
    dp[0] = 1;
    for (int i = 0; i < nums.length; i++) {
        for (int j = addSum; j >= nums[i]; j--) {
            dp[j] += dp[j - nums[i]];
        }
    }
    return dp[addSum];
}
~~~

>   一和零 LeetCode：474

~~~java
public int findMaxForm(String[] strs, int m, int n) {
    int[][] dp = new int[m + 1][n + 1];
    for (String str : strs) {
        char[] chs = str.toCharArray();
        int zeroNum = 0;
        int oneNum = 0;
        for (int i = 0; i < chs.length; i++) {
            if (chs[i] == '0') {
                zeroNum++;
            }
            if (chs[i] == '1') {
                oneNum++;
            }
        }
        for (int i = m; i >= zeroNum; i--) {
            for (int j = n; j >= oneNum; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
            }
        }
    }
    return dp[m][n];
}
~~~

>   零钱兑换II LeetCode：518

~~~java
public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
    return dp[amount];
}
~~~

>   组合总和IV LeetCode：377

~~~java
public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int i = 1; i <= target; i++) {
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] <= i) {
                dp[i] += dp[i - nums[j]];
            }
        }
    }
    return dp[target];
}
~~~

>   零钱兑换 LeetCode：322 最少的硬币个数

~~~java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    for (int i = 0; i <= amount; i++) {
        dp[i] = Integer.MAX_VALUE;
    }
    dp[0] = 0;
    for (int coin : coins) {
        for (int j = coin; j <= amount; j++) {
            if (dp[j-coin] != Integer.MAX_VALUE) {
                dp[j] = Math.min(dp[j], dp[j - coin] + 1);      
            }
        }
    }
    return dp[amount] != Integer.MAX_VALUE ? dp[amount] : -1;
}
~~~

>   完全平方数 LeetCode：279 组成n的完全平方数的最小个数

~~~java
public int numSquares(int n) {
    int[] dp = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        dp[i] = Integer.MAX_VALUE;
    }
    dp[0] = 0;
    for (int i = 1; i * i <=  n; i ++) {
        for (int j = i*i; j <= n; j++) {
            if (dp[j - i*i] != Integer.MAX_VALUE) {
                dp[j] = Math.min(dp[j], dp[j - i*i] + 1);
            }
        }
    }
    return dp[n];
}
~~~

>   单词拆分 LeetCode：139

~~~java
public boolean wordBreak(String s, List<String> wordDict) {
    HashSet<String> set = new HashSet<>(wordDict);
    boolean[] isValid = new boolean[s.length() + 1];
    isValid[0] = true;
    for (int i = 1; i <= s.length(); i++) {
        for (int j = 0; j <= i; j++) {
            if (set.contains(s.substring(j, i)) && isValid[j]) {
                isValid[i] = true;
                break;
            }
        }
    }
    return isValid[s.length()];
}
~~~

>   打家劫舍 LeetCode：198

~~~java
public int rob(int[] nums) {
    int[] dp = new int[nums.length + 1];
    dp[0] = 0;
    dp[1] = nums[0];
    for (int i = 2; i <= nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i-1]);
    }
    return dp[nums.length];
}
~~~

>   打家劫舍II LeetCode：213

~~~java
public int rob(int[] nums) {
    if (nums.length == 1) {
        return nums[0];
    }
    int[] dp1 = new int[nums.length];
    dp1[0] = 0;
    dp1[1] = nums[0];
    for (int i = 2; i < nums.length; i++) {
        dp1[i] = Math.max(dp1[i - 1], dp1[i - 2] + nums[i-1]);
    }
    int[] dp2 = new int[nums.length + 1];
    dp2[1] = 0;
    dp2[2] = nums[1];
    for (int i = 3; i <= nums.length; i++) {
        dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + nums[i-1]);
    }
    return Math.max(dp1[nums.length - 1], dp2[nums.length]);
}
~~~

>   打家劫舍3 LeetCode：337

~~~java
public int rob(TreeNode root) {
    int[] res = robTree(root);
    return Math.max(res[0], res[1]);
}

public int[] robTree(TreeNode root) {
    int[] res = new int[2];
    if (root == null) {
        return res;
    }
    int[] left = robTree(root.left);
    int[] right = robTree(root.right);
    res[0] = root.val + left[1] + right[1];
    res[1] = Math.max(left[0], left[1])+ Math.max(right[0], right[1]);
    return res;
}
~~~

>   买卖股票的最佳时机3 LeetCode：123

~~~java
public int maxProfit(int[] prices) {
    int[][] dp = new int[prices.length][5];
    dp[0][1] = -prices[0];
    dp[0][3] = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
        dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
        dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
        dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
    }
    return Math.max(dp[prices.length - 1][2], dp[prices.length - 1][4]);
}
~~~

>   买卖股票最佳时机4 LeetCode：188.

~~~java
public int maxProfit(int k, int[] prices) {
    int[] dp = new int[2*k + 1];
    for (int i = 1; i <= 2*k; i += 2) {
        dp[i] = -prices[0];
    }
    for (int i = 1; i < prices.length; i++) {
        for (int j = 1; j <= 2*k; j++) {
            if (j % 2 == 1) {
                dp[j] = Math.max(dp[j], dp[j - 1] - prices[i]);
            } else {
                dp[j] = Math.max(dp[j], dp[j - 1] + prices[i]);
            }
        }
    }
    return dp[2*k];
}
~~~

>   买卖股票的最佳时机含冷冻期 LeetCode：309

~~~java
public int maxProfit(int[] prices) {
    int[] dp = new int[4];
    dp[0] = -prices[0]; // 买入
    dp[1] = 0; // 之前卖出 或者 没操作
    dp[2] = 0; // 今天卖出
    dp[3] = 0; // 冷冻期
    for (int i = 1; i < prices.length; i++) {
        int tmp1 = dp[0];
        int tmp2 = dp[2];
        dp[0] = Math.max(dp[0], Math.max(dp[1] - prices[i], dp[3] - prices[i]));
        dp[1] = Math.max(dp[1], dp[3]);
        dp[2] = tmp1 + prices[i];
        dp[3] = tmp2;
    }
    return Math.max(dp[3], Math.max(dp[1], dp[2]));
}
~~~

>   买卖股票的最佳时机含手续费 LeetCode：714

~~~java
public int maxProfit(int[] prices, int fee) {
    int[] dp = new int[2];
    dp[0] = -prices[0];
    dp[1] = 0;
    for (int i = 1; i < prices.length; i++) {
        int tmp1 = dp[0];
        dp[0] = Math.max(dp[0], dp[1] - prices[i]);
        dp[1] = Math.max(dp[1], tmp1 + prices[i] - fee);
    }
    return dp[1];
}
~~~

>   最长递增子序列 LeetCode：300

~~~java
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    int result = 1;
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j <= i; j++) {
            if(nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            } 
        }
        result = Math.max(result, dp[i]);
    }
    return result;
}
~~~

>   最长连续递增序列 LeetCode：674

~~~java
public int findLengthOfLCIS(int[] nums) {
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    int result = 1;
    for (int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i-1]) {
                dp[i] = dp[i-1] + 1;
            }
            result = Math.max(result, dp[i]);
    }
    return result;
}
~~~

>   最长重复子数组 LeetCode：718

~~~java
public int findLength(int[] nums1, int[] nums2) {
    int[][] dp = new int[nums1.length + 1][nums2.length + 1];
    int result = 0;
    for (int i = 1; i <= nums1.length; i++) {
        for (int j = 1; j <= nums2.length; j++) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > result) {
                    result = dp[i][j];
                }
            } 
        }
    }
    return result;
}
~~~

>   最长公共子序列 LeetCode：1143

~~~java
public int longestCommonSubsequence(String text1, String text2) {
    char[] ch1 = text1.toCharArray();
    char[] ch2 = text2.toCharArray();
    int[][] dp = new int[ch1.length + 1][ch2.length + 1];
    for (int i = 1; i <= ch1.length; i++) {
        for (int j = 1; j <= ch2.length; j++) {
            if (ch1[i - 1] == ch2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[ch1.length][ch2.length];
}
~~~

>   不相交的线 LeetCode：1035

~~~java
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        int result = 0;
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    if (dp[i][j] > result) {
                        result = dp[i][j];
                    }
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return result;
    }
~~~

>    判断子序列 LeetCode：392

~~~java
public boolean isSubsequence(String s, String t) {
    int[][] dp = new int[s.length() + 1][t.length() + 1];
    for (int i = 1; i <= s.length(); i++) {
        for (int j = 1; j <= t.length(); j++) {
            if (s.charAt(i - 1) == t.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = dp[i][j - 1];
            }
        }
    }
    if (dp[s.length()][t.length()] == s.length()) {
        return true;
    } else {
        return false;
    }
}
~~~

>   不同的子序列 LeetCode：115  s在t中出现次数

~~~java
~~~

## 10、单调栈 ing

>   每日温度 LeetCode:739

~~~java
public int[] dailyTemperatures(int[] temperatures) {
    int[] result = new int[temperatures.length];
    Stack<Integer> stack = new Stack<>();
    stack.push(0);
    for (int i = 1; i < temperatures.length; i++) {
        if (temperatures[i] <= temperatures[stack.peek()]) {
            stack.push(i);
        } else {
            while(!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
                int index = stack.pop();
                result[index] = i - index;
            }
            stack.push(i);
        }
    }
    while (!stack.isEmpty()) {
        int index = stack.pop();
        result[index] = 0;
    }
    return result;
}
~~~

>   下一个更大元素 LeetCode:496

~~~java
~~~



## 11、图论